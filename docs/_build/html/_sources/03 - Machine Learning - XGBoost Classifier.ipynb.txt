{
 "cells": [
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "# XGBoost Classifier\n",
    "\n",
    "The first algorithm that we will use is the XGBoost with its classic classifier. This is the classic simple algorithm from XGBoost library, further a more complex one will be used. This algorithm will be used for each generated feature, namelly:\n",
    "\n",
    "- Periodograms\n",
    "- Bayes Similarity\n",
    "- Hidden Markov Models\n",
    "\n",
    "All approaches will pass trough the common machine learning pipeline, where we must:\n",
    "\n",
    "- Normalize the data (if necessary)\n",
    "- Divide the data between trainning and testing\n",
    "- Search the hyper parameters\n",
    "- Cross validate the models\n",
    "- Analyse the results"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## Periodograms\n",
    "\n",
    "The application using the periodograms is actually pretty simple, now that the data is prepared and all of those preprocessing from last pipeline step is already done. The algorithm became straigh forward. First it is necessary to read the features generated."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 1,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "dict_keys(['features', 'labels'])"
      ]
     },
     "execution_count": 1,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "import pickle \n",
    "\n",
    "file_name = './features/freq_data/freq_data.pkl' \n",
    "with open(file_name, 'rb') as file:\n",
    "    freq_data = pickle.load(file)\n",
    "freq_data.keys()"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "### Manipulate features\n",
    "\n",
    "After reading the data, it is necessary to create the classical regression structure model in the format $Y = f\\left(\\Theta, X\\right)$, normalize the feature data and encode any possible label data into numerical classes. This is just the preparation for the machine leaning algorithm to guarantee that the provided info is properlly designed for any machine learning classical form."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 2,
   "metadata": {},
   "outputs": [],
   "source": [
    "import numpy as np\n",
    "from sklearn import preprocessing\n",
    "\n",
    "# Create the label encoder\n",
    "le_freq = preprocessing.LabelEncoder()\n",
    "le_freq.fit(freq_data['labels'])\n",
    "\n",
    "# Define the regression model\n",
    "regressors = preprocessing.normalize(freq_data['features']['spec'])\n",
    "outputs = le_freq.transform(freq_data['labels'])"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 3,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "12758"
      ]
     },
     "execution_count": 3,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "regressors.shape[1]"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "Also it is interesting to reduce the features dimension to build a simpler model. It is not necessary to create a classifier with such amount (12758 features...) of features. There are several techniques that can be used to reduce the features dimensions. The Principal Component Analisys, is very effective when dealing with high dimensional data. Here the `PCA` algorithm from the `sklearn` library is used."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 4,
   "metadata": {},
   "outputs": [],
   "source": [
    "from sklearn.decomposition import PCA\n",
    "\n",
    "# Create the PCA decomposer\n",
    "pca_dec = PCA(n_components=70, svd_solver='arpack')\n",
    "\n",
    "# Train the PCA object\n",
    "pca_dec.fit(regressors)\n",
    "\n",
    "# Transform the data using\n",
    "# the PCA model\n",
    "pca_regressor = pca_dec.transform(regressors)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "### Train-test data split\n",
    "\n",
    "Next it is necessary to segregate the data into a set for validation and one for trainning the model."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 5,
   "metadata": {},
   "outputs": [],
   "source": [
    "from sklearn.model_selection import train_test_split\n",
    "\n",
    "X_train, X_test, y_train, y_test = train_test_split( \n",
    "    pca_regressor, outputs, test_size=0.33, random_state=42)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "### Hyper tunning\n",
    "\n",
    "We could consider tunning the model hyper parameters to answer questions such as:\n",
    "\n",
    "- Wich value of `n_estimators` is the best for this model and data?\n",
    "- Wich cost function is the best to be selected as `objective` for this model?\n",
    "\n",
    "We could do a hyper search, to find the best hyper parameters for this model, automating the hyper parameter selection. There are several already builded algorithms to optimize this parameter search, and build find with high performance the best parameters, provided a set of possible values. But, to understand what those algorithms actually does, we could once build our own search algorithm...\n",
    "\n",
    "As an example, lets run a first handly defined hyper parameter tunning using the confusion matrix of the model:"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 6,
   "metadata": {},
   "outputs": [],
   "source": [
    "import xgboost as xgb\n",
    "from sklearn.metrics import confusion_matrix\n",
    "\n",
    "# Define the model parameters \n",
    "param_dist = {\n",
    "    'objective':'binary:logistic', \n",
    "    'n_estimators' : 11\n",
    "}\n",
    "\n",
    "# Create the range parameters to \n",
    "# search\n",
    "n_estimators = [ k+1 for k in range(100)]\n",
    "\n",
    "# Create the plotting variable\n",
    "plot_vals = {\n",
    "    'true': {\n",
    "        'confirmed targets': [],\n",
    "        'eclipsing binaries': [],\n",
    "    },\n",
    "    'false': {\n",
    "        'confirmed targets': [],\n",
    "        'eclipsing binaries': [],\n",
    "    }\n",
    "}\n",
    "\n",
    "# Estimate and validate each candidate\n",
    "for opt in n_estimators:\n",
    "    # Update the model parameters\n",
    "    param_dist['n_estimators'] = opt\n",
    "    # Create the xgBoost classifier\n",
    "    clfs = xgb.XGBClassifier(**param_dist)\n",
    "    # Fit the model to the data\n",
    "    clfs.fit(X_train, y_train,\n",
    "            eval_metric='logloss',\n",
    "            verbose=True)\n",
    "    # Estimate the test output\n",
    "    y_pred = clfs.predict(X_test)\n",
    "    # Compute the confusion matrix\n",
    "    conf_mat = confusion_matrix(\n",
    "        y_test, y_pred,\n",
    "        normalize='true')\n",
    "    # Save the confusion matrix\n",
    "    plot_vals['true']['confirmed targets'].append(conf_mat[0,0])\n",
    "    plot_vals['true']['eclipsing binaries'].append(conf_mat[1,1])\n",
    "    plot_vals['false']['confirmed targets'].append(conf_mat[0,1])\n",
    "    plot_vals['false']['eclipsing binaries'].append(conf_mat[1,0])"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 7,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/html": [
       "\n",
       "    <div class=\"bk-root\">\n",
       "        <a href=\"https://bokeh.org\" target=\"_blank\" class=\"bk-logo bk-logo-small bk-logo-notebook\"></a>\n",
       "        <span id=\"1001\">Loading BokehJS ...</span>\n",
       "    </div>"
      ]
     },
     "metadata": {},
     "output_type": "display_data"
    },
    {
     "data": {
      "application/javascript": [
       "\n",
       "(function(root) {\n",
       "  function now() {\n",
       "    return new Date();\n",
       "  }\n",
       "\n",
       "  var force = true;\n",
       "\n",
       "  if (typeof root._bokeh_onload_callbacks === \"undefined\" || force === true) {\n",
       "    root._bokeh_onload_callbacks = [];\n",
       "    root._bokeh_is_loading = undefined;\n",
       "  }\n",
       "\n",
       "  var JS_MIME_TYPE = 'application/javascript';\n",
       "  var HTML_MIME_TYPE = 'text/html';\n",
       "  var EXEC_MIME_TYPE = 'application/vnd.bokehjs_exec.v0+json';\n",
       "  var CLASS_NAME = 'output_bokeh rendered_html';\n",
       "\n",
       "  /**\n",
       "   * Render data to the DOM node\n",
       "   */\n",
       "  function render(props, node) {\n",
       "    var script = document.createElement(\"script\");\n",
       "    node.appendChild(script);\n",
       "  }\n",
       "\n",
       "  /**\n",
       "   * Handle when an output is cleared or removed\n",
       "   */\n",
       "  function handleClearOutput(event, handle) {\n",
       "    var cell = handle.cell;\n",
       "\n",
       "    var id = cell.output_area._bokeh_element_id;\n",
       "    var server_id = cell.output_area._bokeh_server_id;\n",
       "    // Clean up Bokeh references\n",
       "    if (id != null && id in Bokeh.index) {\n",
       "      Bokeh.index[id].model.document.clear();\n",
       "      delete Bokeh.index[id];\n",
       "    }\n",
       "\n",
       "    if (server_id !== undefined) {\n",
       "      // Clean up Bokeh references\n",
       "      var cmd = \"from bokeh.io.state import curstate; print(curstate().uuid_to_server['\" + server_id + \"'].get_sessions()[0].document.roots[0]._id)\";\n",
       "      cell.notebook.kernel.execute(cmd, {\n",
       "        iopub: {\n",
       "          output: function(msg) {\n",
       "            var id = msg.content.text.trim();\n",
       "            if (id in Bokeh.index) {\n",
       "              Bokeh.index[id].model.document.clear();\n",
       "              delete Bokeh.index[id];\n",
       "            }\n",
       "          }\n",
       "        }\n",
       "      });\n",
       "      // Destroy server and session\n",
       "      var cmd = \"import bokeh.io.notebook as ion; ion.destroy_server('\" + server_id + \"')\";\n",
       "      cell.notebook.kernel.execute(cmd);\n",
       "    }\n",
       "  }\n",
       "\n",
       "  /**\n",
       "   * Handle when a new output is added\n",
       "   */\n",
       "  function handleAddOutput(event, handle) {\n",
       "    var output_area = handle.output_area;\n",
       "    var output = handle.output;\n",
       "\n",
       "    // limit handleAddOutput to display_data with EXEC_MIME_TYPE content only\n",
       "    if ((output.output_type != \"display_data\") || (!output.data.hasOwnProperty(EXEC_MIME_TYPE))) {\n",
       "      return\n",
       "    }\n",
       "\n",
       "    var toinsert = output_area.element.find(\".\" + CLASS_NAME.split(' ')[0]);\n",
       "\n",
       "    if (output.metadata[EXEC_MIME_TYPE][\"id\"] !== undefined) {\n",
       "      toinsert[toinsert.length - 1].firstChild.textContent = output.data[JS_MIME_TYPE];\n",
       "      // store reference to embed id on output_area\n",
       "      output_area._bokeh_element_id = output.metadata[EXEC_MIME_TYPE][\"id\"];\n",
       "    }\n",
       "    if (output.metadata[EXEC_MIME_TYPE][\"server_id\"] !== undefined) {\n",
       "      var bk_div = document.createElement(\"div\");\n",
       "      bk_div.innerHTML = output.data[HTML_MIME_TYPE];\n",
       "      var script_attrs = bk_div.children[0].attributes;\n",
       "      for (var i = 0; i < script_attrs.length; i++) {\n",
       "        toinsert[toinsert.length - 1].firstChild.setAttribute(script_attrs[i].name, script_attrs[i].value);\n",
       "        toinsert[toinsert.length - 1].firstChild.textContent = bk_div.children[0].textContent\n",
       "      }\n",
       "      // store reference to server id on output_area\n",
       "      output_area._bokeh_server_id = output.metadata[EXEC_MIME_TYPE][\"server_id\"];\n",
       "    }\n",
       "  }\n",
       "\n",
       "  function register_renderer(events, OutputArea) {\n",
       "\n",
       "    function append_mime(data, metadata, element) {\n",
       "      // create a DOM node to render to\n",
       "      var toinsert = this.create_output_subarea(\n",
       "        metadata,\n",
       "        CLASS_NAME,\n",
       "        EXEC_MIME_TYPE\n",
       "      );\n",
       "      this.keyboard_manager.register_events(toinsert);\n",
       "      // Render to node\n",
       "      var props = {data: data, metadata: metadata[EXEC_MIME_TYPE]};\n",
       "      render(props, toinsert[toinsert.length - 1]);\n",
       "      element.append(toinsert);\n",
       "      return toinsert\n",
       "    }\n",
       "\n",
       "    /* Handle when an output is cleared or removed */\n",
       "    events.on('clear_output.CodeCell', handleClearOutput);\n",
       "    events.on('delete.Cell', handleClearOutput);\n",
       "\n",
       "    /* Handle when a new output is added */\n",
       "    events.on('output_added.OutputArea', handleAddOutput);\n",
       "\n",
       "    /**\n",
       "     * Register the mime type and append_mime function with output_area\n",
       "     */\n",
       "    OutputArea.prototype.register_mime_type(EXEC_MIME_TYPE, append_mime, {\n",
       "      /* Is output safe? */\n",
       "      safe: true,\n",
       "      /* Index of renderer in `output_area.display_order` */\n",
       "      index: 0\n",
       "    });\n",
       "  }\n",
       "\n",
       "  // register the mime type if in Jupyter Notebook environment and previously unregistered\n",
       "  if (root.Jupyter !== undefined) {\n",
       "    var events = require('base/js/events');\n",
       "    var OutputArea = require('notebook/js/outputarea').OutputArea;\n",
       "\n",
       "    if (OutputArea.prototype.mime_types().indexOf(EXEC_MIME_TYPE) == -1) {\n",
       "      register_renderer(events, OutputArea);\n",
       "    }\n",
       "  }\n",
       "\n",
       "  \n",
       "  if (typeof (root._bokeh_timeout) === \"undefined\" || force === true) {\n",
       "    root._bokeh_timeout = Date.now() + 5000;\n",
       "    root._bokeh_failed_load = false;\n",
       "  }\n",
       "\n",
       "  var NB_LOAD_WARNING = {'data': {'text/html':\n",
       "     \"<div style='background-color: #fdd'>\\n\"+\n",
       "     \"<p>\\n\"+\n",
       "     \"BokehJS does not appear to have successfully loaded. If loading BokehJS from CDN, this \\n\"+\n",
       "     \"may be due to a slow or bad network connection. Possible fixes:\\n\"+\n",
       "     \"</p>\\n\"+\n",
       "     \"<ul>\\n\"+\n",
       "     \"<li>re-rerun `output_notebook()` to attempt to load from CDN again, or</li>\\n\"+\n",
       "     \"<li>use INLINE resources instead, as so:</li>\\n\"+\n",
       "     \"</ul>\\n\"+\n",
       "     \"<code>\\n\"+\n",
       "     \"from bokeh.resources import INLINE\\n\"+\n",
       "     \"output_notebook(resources=INLINE)\\n\"+\n",
       "     \"</code>\\n\"+\n",
       "     \"</div>\"}};\n",
       "\n",
       "  function display_loaded() {\n",
       "    var el = document.getElementById(\"1001\");\n",
       "    if (el != null) {\n",
       "      el.textContent = \"BokehJS is loading...\";\n",
       "    }\n",
       "    if (root.Bokeh !== undefined) {\n",
       "      if (el != null) {\n",
       "        el.textContent = \"BokehJS \" + root.Bokeh.version + \" successfully loaded.\";\n",
       "      }\n",
       "    } else if (Date.now() < root._bokeh_timeout) {\n",
       "      setTimeout(display_loaded, 100)\n",
       "    }\n",
       "  }\n",
       "\n",
       "\n",
       "  function run_callbacks() {\n",
       "    try {\n",
       "      root._bokeh_onload_callbacks.forEach(function(callback) {\n",
       "        if (callback != null)\n",
       "          callback();\n",
       "      });\n",
       "    } finally {\n",
       "      delete root._bokeh_onload_callbacks\n",
       "    }\n",
       "    console.debug(\"Bokeh: all callbacks have finished\");\n",
       "  }\n",
       "\n",
       "  function load_libs(css_urls, js_urls, callback) {\n",
       "    if (css_urls == null) css_urls = [];\n",
       "    if (js_urls == null) js_urls = [];\n",
       "\n",
       "    root._bokeh_onload_callbacks.push(callback);\n",
       "    if (root._bokeh_is_loading > 0) {\n",
       "      console.debug(\"Bokeh: BokehJS is being loaded, scheduling callback at\", now());\n",
       "      return null;\n",
       "    }\n",
       "    if (js_urls == null || js_urls.length === 0) {\n",
       "      run_callbacks();\n",
       "      return null;\n",
       "    }\n",
       "    console.debug(\"Bokeh: BokehJS not loaded, scheduling load and callback at\", now());\n",
       "    root._bokeh_is_loading = css_urls.length + js_urls.length;\n",
       "\n",
       "    function on_load() {\n",
       "      root._bokeh_is_loading--;\n",
       "      if (root._bokeh_is_loading === 0) {\n",
       "        console.debug(\"Bokeh: all BokehJS libraries/stylesheets loaded\");\n",
       "        run_callbacks()\n",
       "      }\n",
       "    }\n",
       "\n",
       "    function on_error() {\n",
       "      console.error(\"failed to load \" + url);\n",
       "    }\n",
       "\n",
       "    for (var i = 0; i < css_urls.length; i++) {\n",
       "      var url = css_urls[i];\n",
       "      const element = document.createElement(\"link\");\n",
       "      element.onload = on_load;\n",
       "      element.onerror = on_error;\n",
       "      element.rel = \"stylesheet\";\n",
       "      element.type = \"text/css\";\n",
       "      element.href = url;\n",
       "      console.debug(\"Bokeh: injecting link tag for BokehJS stylesheet: \", url);\n",
       "      document.body.appendChild(element);\n",
       "    }\n",
       "\n",
       "    const hashes = {\"https://cdn.bokeh.org/bokeh/release/bokeh-2.0.1.min.js\": \"JpP8FXbgAZLkfur7LiK3j9AGBhHNIvF742meBJrjO2ShJDhCG2I1uVvW+0DUtrmc\", \"https://cdn.bokeh.org/bokeh/release/bokeh-widgets-2.0.1.min.js\": \"xZlADit0Q04ISQEdKg2k3L4W9AwQBAuDs9nJL9fM/WwzL1tEU9VPNezOFX0nLEAz\", \"https://cdn.bokeh.org/bokeh/release/bokeh-tables-2.0.1.min.js\": \"4BuPRZkdMKSnj3zoxiNrQ86XgNw0rYmBOxe7nshquXwwcauupgBF2DHLVG1WuZlV\", \"https://cdn.bokeh.org/bokeh/release/bokeh-gl-2.0.1.min.js\": \"Dv1SQ87hmDqK6S5OhBf0bCuwAEvL5QYL0PuR/F1SPVhCS/r/abjkbpKDYL2zeM19\"};\n",
       "\n",
       "    for (var i = 0; i < js_urls.length; i++) {\n",
       "      var url = js_urls[i];\n",
       "      var element = document.createElement('script');\n",
       "      element.onload = on_load;\n",
       "      element.onerror = on_error;\n",
       "      element.async = false;\n",
       "      element.src = url;\n",
       "      if (url in hashes) {\n",
       "        element.crossOrigin = \"anonymous\";\n",
       "        element.integrity = \"sha384-\" + hashes[url];\n",
       "      }\n",
       "      console.debug(\"Bokeh: injecting script tag for BokehJS library: \", url);\n",
       "      document.head.appendChild(element);\n",
       "    }\n",
       "  };var element = document.getElementById(\"1001\");\n",
       "  if (element == null) {\n",
       "    console.error(\"Bokeh: ERROR: autoload.js configured with elementid '1001' but no matching script tag was found. \")\n",
       "    return false;\n",
       "  }\n",
       "\n",
       "  function inject_raw_css(css) {\n",
       "    const element = document.createElement(\"style\");\n",
       "    element.appendChild(document.createTextNode(css));\n",
       "    document.body.appendChild(element);\n",
       "  }\n",
       "\n",
       "  \n",
       "  var js_urls = [\"https://cdn.bokeh.org/bokeh/release/bokeh-2.0.1.min.js\", \"https://cdn.bokeh.org/bokeh/release/bokeh-widgets-2.0.1.min.js\", \"https://cdn.bokeh.org/bokeh/release/bokeh-tables-2.0.1.min.js\", \"https://cdn.bokeh.org/bokeh/release/bokeh-gl-2.0.1.min.js\"];\n",
       "  var css_urls = [];\n",
       "  \n",
       "\n",
       "  var inline_js = [\n",
       "    function(Bokeh) {\n",
       "      Bokeh.set_log_level(\"info\");\n",
       "    },\n",
       "    function(Bokeh) {\n",
       "    \n",
       "    \n",
       "    }\n",
       "  ];\n",
       "\n",
       "  function run_inline_js() {\n",
       "    \n",
       "    if (root.Bokeh !== undefined || force === true) {\n",
       "      \n",
       "    for (var i = 0; i < inline_js.length; i++) {\n",
       "      inline_js[i].call(root, root.Bokeh);\n",
       "    }\n",
       "    if (force === true) {\n",
       "        display_loaded();\n",
       "      }} else if (Date.now() < root._bokeh_timeout) {\n",
       "      setTimeout(run_inline_js, 100);\n",
       "    } else if (!root._bokeh_failed_load) {\n",
       "      console.log(\"Bokeh: BokehJS failed to load within specified timeout.\");\n",
       "      root._bokeh_failed_load = true;\n",
       "    } else if (force !== true) {\n",
       "      var cell = $(document.getElementById(\"1001\")).parents('.cell').data().cell;\n",
       "      cell.output_area.append_execute_result(NB_LOAD_WARNING)\n",
       "    }\n",
       "\n",
       "  }\n",
       "\n",
       "  if (root._bokeh_is_loading === 0) {\n",
       "    console.debug(\"Bokeh: BokehJS loaded, going straight to plotting\");\n",
       "    run_inline_js();\n",
       "  } else {\n",
       "    load_libs(css_urls, js_urls, function() {\n",
       "      console.debug(\"Bokeh: BokehJS plotting callback run at\", now());\n",
       "      run_inline_js();\n",
       "    });\n",
       "  }\n",
       "}(window));"
      ],
      "application/vnd.bokehjs_load.v0+json": "\n(function(root) {\n  function now() {\n    return new Date();\n  }\n\n  var force = true;\n\n  if (typeof root._bokeh_onload_callbacks === \"undefined\" || force === true) {\n    root._bokeh_onload_callbacks = [];\n    root._bokeh_is_loading = undefined;\n  }\n\n  \n\n  \n  if (typeof (root._bokeh_timeout) === \"undefined\" || force === true) {\n    root._bokeh_timeout = Date.now() + 5000;\n    root._bokeh_failed_load = false;\n  }\n\n  var NB_LOAD_WARNING = {'data': {'text/html':\n     \"<div style='background-color: #fdd'>\\n\"+\n     \"<p>\\n\"+\n     \"BokehJS does not appear to have successfully loaded. If loading BokehJS from CDN, this \\n\"+\n     \"may be due to a slow or bad network connection. Possible fixes:\\n\"+\n     \"</p>\\n\"+\n     \"<ul>\\n\"+\n     \"<li>re-rerun `output_notebook()` to attempt to load from CDN again, or</li>\\n\"+\n     \"<li>use INLINE resources instead, as so:</li>\\n\"+\n     \"</ul>\\n\"+\n     \"<code>\\n\"+\n     \"from bokeh.resources import INLINE\\n\"+\n     \"output_notebook(resources=INLINE)\\n\"+\n     \"</code>\\n\"+\n     \"</div>\"}};\n\n  function display_loaded() {\n    var el = document.getElementById(\"1001\");\n    if (el != null) {\n      el.textContent = \"BokehJS is loading...\";\n    }\n    if (root.Bokeh !== undefined) {\n      if (el != null) {\n        el.textContent = \"BokehJS \" + root.Bokeh.version + \" successfully loaded.\";\n      }\n    } else if (Date.now() < root._bokeh_timeout) {\n      setTimeout(display_loaded, 100)\n    }\n  }\n\n\n  function run_callbacks() {\n    try {\n      root._bokeh_onload_callbacks.forEach(function(callback) {\n        if (callback != null)\n          callback();\n      });\n    } finally {\n      delete root._bokeh_onload_callbacks\n    }\n    console.debug(\"Bokeh: all callbacks have finished\");\n  }\n\n  function load_libs(css_urls, js_urls, callback) {\n    if (css_urls == null) css_urls = [];\n    if (js_urls == null) js_urls = [];\n\n    root._bokeh_onload_callbacks.push(callback);\n    if (root._bokeh_is_loading > 0) {\n      console.debug(\"Bokeh: BokehJS is being loaded, scheduling callback at\", now());\n      return null;\n    }\n    if (js_urls == null || js_urls.length === 0) {\n      run_callbacks();\n      return null;\n    }\n    console.debug(\"Bokeh: BokehJS not loaded, scheduling load and callback at\", now());\n    root._bokeh_is_loading = css_urls.length + js_urls.length;\n\n    function on_load() {\n      root._bokeh_is_loading--;\n      if (root._bokeh_is_loading === 0) {\n        console.debug(\"Bokeh: all BokehJS libraries/stylesheets loaded\");\n        run_callbacks()\n      }\n    }\n\n    function on_error() {\n      console.error(\"failed to load \" + url);\n    }\n\n    for (var i = 0; i < css_urls.length; i++) {\n      var url = css_urls[i];\n      const element = document.createElement(\"link\");\n      element.onload = on_load;\n      element.onerror = on_error;\n      element.rel = \"stylesheet\";\n      element.type = \"text/css\";\n      element.href = url;\n      console.debug(\"Bokeh: injecting link tag for BokehJS stylesheet: \", url);\n      document.body.appendChild(element);\n    }\n\n    const hashes = {\"https://cdn.bokeh.org/bokeh/release/bokeh-2.0.1.min.js\": \"JpP8FXbgAZLkfur7LiK3j9AGBhHNIvF742meBJrjO2ShJDhCG2I1uVvW+0DUtrmc\", \"https://cdn.bokeh.org/bokeh/release/bokeh-widgets-2.0.1.min.js\": \"xZlADit0Q04ISQEdKg2k3L4W9AwQBAuDs9nJL9fM/WwzL1tEU9VPNezOFX0nLEAz\", \"https://cdn.bokeh.org/bokeh/release/bokeh-tables-2.0.1.min.js\": \"4BuPRZkdMKSnj3zoxiNrQ86XgNw0rYmBOxe7nshquXwwcauupgBF2DHLVG1WuZlV\", \"https://cdn.bokeh.org/bokeh/release/bokeh-gl-2.0.1.min.js\": \"Dv1SQ87hmDqK6S5OhBf0bCuwAEvL5QYL0PuR/F1SPVhCS/r/abjkbpKDYL2zeM19\"};\n\n    for (var i = 0; i < js_urls.length; i++) {\n      var url = js_urls[i];\n      var element = document.createElement('script');\n      element.onload = on_load;\n      element.onerror = on_error;\n      element.async = false;\n      element.src = url;\n      if (url in hashes) {\n        element.crossOrigin = \"anonymous\";\n        element.integrity = \"sha384-\" + hashes[url];\n      }\n      console.debug(\"Bokeh: injecting script tag for BokehJS library: \", url);\n      document.head.appendChild(element);\n    }\n  };var element = document.getElementById(\"1001\");\n  if (element == null) {\n    console.error(\"Bokeh: ERROR: autoload.js configured with elementid '1001' but no matching script tag was found. \")\n    return false;\n  }\n\n  function inject_raw_css(css) {\n    const element = document.createElement(\"style\");\n    element.appendChild(document.createTextNode(css));\n    document.body.appendChild(element);\n  }\n\n  \n  var js_urls = [\"https://cdn.bokeh.org/bokeh/release/bokeh-2.0.1.min.js\", \"https://cdn.bokeh.org/bokeh/release/bokeh-widgets-2.0.1.min.js\", \"https://cdn.bokeh.org/bokeh/release/bokeh-tables-2.0.1.min.js\", \"https://cdn.bokeh.org/bokeh/release/bokeh-gl-2.0.1.min.js\"];\n  var css_urls = [];\n  \n\n  var inline_js = [\n    function(Bokeh) {\n      Bokeh.set_log_level(\"info\");\n    },\n    function(Bokeh) {\n    \n    \n    }\n  ];\n\n  function run_inline_js() {\n    \n    if (root.Bokeh !== undefined || force === true) {\n      \n    for (var i = 0; i < inline_js.length; i++) {\n      inline_js[i].call(root, root.Bokeh);\n    }\n    if (force === true) {\n        display_loaded();\n      }} else if (Date.now() < root._bokeh_timeout) {\n      setTimeout(run_inline_js, 100);\n    } else if (!root._bokeh_failed_load) {\n      console.log(\"Bokeh: BokehJS failed to load within specified timeout.\");\n      root._bokeh_failed_load = true;\n    } else if (force !== true) {\n      var cell = $(document.getElementById(\"1001\")).parents('.cell').data().cell;\n      cell.output_area.append_execute_result(NB_LOAD_WARNING)\n    }\n\n  }\n\n  if (root._bokeh_is_loading === 0) {\n    console.debug(\"Bokeh: BokehJS loaded, going straight to plotting\");\n    run_inline_js();\n  } else {\n    load_libs(css_urls, js_urls, function() {\n      console.debug(\"Bokeh: BokehJS plotting callback run at\", now());\n      run_inline_js();\n    });\n  }\n}(window));"
     },
     "metadata": {},
     "output_type": "display_data"
    }
   ],
   "source": [
    "from utils import *\n",
    "\n",
    "# Line plot each confidence matrix parameter\n",
    "x_data = [n_estimators, n_estimators, n_estimators, n_estimators]\n",
    "y_data = [plot_vals['true']['confirmed targets'],\n",
    "          plot_vals['true']['eclipsing binaries'],\n",
    "          plot_vals['false']['confirmed targets'],\n",
    "          plot_vals['false']['eclipsing binaries']]\n",
    "legends= ['True - C.T.', 'True - E.B.', 'False - C.T.', 'False - E.B.']\n",
    "colors = [6, 7, 2, 3]\n",
    "\n",
    "p = visual.multline_plot(x_data, y_data,\n",
    "                         legend_label=legends, \n",
    "                         title='Hyper parameter search - Confusion parameters plot',\n",
    "                         color_index=colors,\n",
    "                         y_axis={'label': 'Proportion'},\n",
    "                         x_axis={'label': 'n_estimators'})\n",
    "visual.show_plot(p)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "![Hyper parameter search - XGBoost Classifier - Periodogram](./images/nb_gallery/bokeh_plot(23).png)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "### Train model\n",
    "\n",
    "After running the hyper parameter search we can create a model with the best defined hyper parameters, or setup parameters, and consolidate the model in to the best version for further performance analysis. The model is saved on a particular variable, such as `freq_clf` to be further used in some vote chain model, if further necessary. \n",
    "\n",
    "> *One interesting result from the above result, is that the best compromise result happens at the $n_x = 5$ not on $n_x=4$ as it seems. Even though for the $n_x=4$ the algorithm is able to get all the exo planets, the compromise on having a confidence of only 66% for the eclipsing binaries classification (classifier close to a coin flipper to classify eclipsing binaries), doesn't allow us to select $n_x=4$. Therefore the best trade-off on both classes happens at $n_x=5$.* "
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 8,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "XGBClassifier(base_score=0.5, booster=None, colsample_bylevel=1,\n",
       "              colsample_bynode=1, colsample_bytree=1, gamma=0, gpu_id=-1,\n",
       "              importance_type='gain', interaction_constraints=None,\n",
       "              learning_rate=0.300000012, max_delta_step=0, max_depth=6,\n",
       "              min_child_weight=1, missing=nan, monotone_constraints=None,\n",
       "              n_estimators=5, n_jobs=0, num_parallel_tree=1,\n",
       "              objective='binary:logistic', random_state=0, reg_alpha=0,\n",
       "              reg_lambda=1, scale_pos_weight=1, subsample=1, tree_method=None,\n",
       "              validate_parameters=False, verbosity=0)"
      ]
     },
     "execution_count": 8,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "# XGBoost Classifier model parameters\n",
    "param_dist = {\n",
    "    'verbosity': 0,\n",
    "    'objective':'binary:logistic', \n",
    "    'n_estimators' : 5\n",
    "}\n",
    "\n",
    "# Create the model classifier\n",
    "freq_clf = xgb.XGBClassifier(**param_dist)\n",
    "\n",
    "# Train the model\n",
    "freq_clf.fit(X_train, y_train,\n",
    "              eval_set=[\n",
    "                (X_train, y_train), \n",
    "                (X_test, y_test)\n",
    "              ],\n",
    "              eval_metric='logloss',\n",
    "              verbose=False)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "### Results\n",
    "\n",
    "In this part it is presented the results from the classification algorithm. Both regarding the data visualization and the model classification quality. "
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 9,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "{ 'validation_0': { 'logloss': [ 0.537111,\n",
      "                                 0.449156,\n",
      "                                 0.384568,\n",
      "                                 0.327504,\n",
      "                                 0.280901]},\n",
      "  'validation_1': { 'logloss': [ 0.609796,\n",
      "                                 0.574501,\n",
      "                                 0.546393,\n",
      "                                 0.504637,\n",
      "                                 0.509942]}}\n"
     ]
    }
   ],
   "source": [
    "import pprint\n",
    "pp = pprint.PrettyPrinter(indent=2)\n",
    "\n",
    "pp.pprint(freq_clf.evals_result())"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 10,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "image/png": "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\n",
      "text/plain": [
       "<Figure size 432x288 with 2 Axes>"
      ]
     },
     "metadata": {
      "needs_background": "light"
     },
     "output_type": "display_data"
    }
   ],
   "source": [
    "import matplotlib.pyplot as plt\n",
    "from sklearn.metrics import plot_confusion_matrix\n",
    "\n",
    "disp = plot_confusion_matrix(freq_clf, X_test, y_test,\n",
    "                             display_labels=le_freq.classes_,\n",
    "                             cmap=plt.cm.Blues,\n",
    "                             normalize='true')\n",
    "disp.ax_.set_title('Periodogram Classifier - Confusion matrix')\n",
    "plt.show()"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "#### Comments\n",
    "\n",
    "*From this results it is possible to see that the classifier using periodogram amplitudes can get some interesting knowledge on the eclipsing binaries classification, and have an even better results for the exo planets (confirmed target labels). Also the results are not just good considering the classification capability, but also considering the robustness of the algorithm. The robustness quality can be checked from the printed loss, which shows a continous descending loss for both the test and train data.*"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## Naive Bayes likelihood\n",
    "\n",
    "Here we will read the Naive Bayes model parameters estimated for each light curve and use this information as feature for the xgBoost classifier. To start this approach, we must first read the Bayes features saved from last step:"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 11,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "dict_keys(['features', 'labels'])"
      ]
     },
     "execution_count": 11,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "import pickle \n",
    "\n",
    "file_name = './features/bayes_data/nx_6/bayes_data.pkl'\n",
    "with open(file_name, 'rb') as file:\n",
    "    bayes_data = pickle.load(file)\n",
    "bayes_data.keys()"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "### Manipulate features\n",
    "\n",
    "After reading the data, it is necessary to create the classical regression structure model in the format $Y = f\\left(\\Theta, X\\right)$, normalize the feature data and encode any possible label data into numerical classes. This is just the preparation for the machine leaning algorithm to guarantee that the provided info is properlly designed for any machine learning classical form."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 12,
   "metadata": {},
   "outputs": [],
   "source": [
    "import numpy as np\n",
    "from sklearn import preprocessing\n",
    "\n",
    "# Create the label encoder\n",
    "le_bayes = preprocessing.LabelEncoder()\n",
    "le_bayes.fit(bayes_data['labels'])\n",
    "\n",
    "# Define the regression model\n",
    "regressors = preprocessing.normalize(bayes_data['features']['params'])\n",
    "outputs = le_bayes.transform(bayes_data['labels'])"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "### Train-test data split\n",
    "\n",
    "Next it is necessary to segregate the data into a set for validation and one for trainning the model."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 13,
   "metadata": {},
   "outputs": [],
   "source": [
    "from sklearn.model_selection import train_test_split\n",
    "\n",
    "X_train, X_test, y_train, y_test = train_test_split( \n",
    "    regressors, outputs, test_size=0.33, random_state=42)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "### Hyper tunning\n",
    "\n",
    "We could consider tunning the model hyper parameters to answer questions such as:\n",
    "\n",
    "- Wich value of `n_estimators` is the best for this model and data?\n",
    "- Wich cost function is the best to be selected as `objective` for this model?\n",
    "\n",
    "We could do a hyper search, to find the best hyper parameters for this model, automating the hyper parameter selection. There are several already builded algorithms to optimize this parameter search, and build find with high performance the best parameters, provided a set of possible values. But, to understand what those algorithms actually does, we could once build our own search algorithm...\n",
    "\n",
    "As an example, lets run a first handly defined hyper parameter tunning using the confusion matrix of the model:"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 14,
   "metadata": {},
   "outputs": [],
   "source": [
    "import xgboost as xgb\n",
    "from sklearn.metrics import confusion_matrix\n",
    "\n",
    "# Define the model parameters \n",
    "param_dist = {\n",
    "    'objective':'binary:logistic', \n",
    "    'n_estimators' : 11\n",
    "}\n",
    "\n",
    "# Create the range parameters to \n",
    "# search\n",
    "n_estimators = [ k+1 for k in range(100)]\n",
    "\n",
    "# Create the plotting variable\n",
    "plot_vals = {\n",
    "    'true': {\n",
    "        'confirmed targets': [],\n",
    "        'eclipsing binaries': [],\n",
    "    },\n",
    "    'false': {\n",
    "        'confirmed targets': [],\n",
    "        'eclipsing binaries': [],\n",
    "    }\n",
    "}\n",
    "\n",
    "# Estimate and validate each candidate\n",
    "for opt in n_estimators:\n",
    "    # Update the model parameters\n",
    "    param_dist['n_estimators'] = opt\n",
    "    # Create the xgBoost classifier\n",
    "    clfs = xgb.XGBClassifier(**param_dist)\n",
    "    # Fit the model to the data\n",
    "    clfs.fit(X_train, y_train,\n",
    "            eval_metric='logloss',\n",
    "            verbose=True)\n",
    "    # Estimate the test output\n",
    "    y_pred = clfs.predict(X_test)\n",
    "    # Compute the confusion matrix\n",
    "    conf_mat = confusion_matrix(\n",
    "        y_test, y_pred,\n",
    "        normalize='true')\n",
    "    # Save the confusion matrix\n",
    "    plot_vals['true']['confirmed targets'].append(conf_mat[0,0])\n",
    "    plot_vals['true']['eclipsing binaries'].append(conf_mat[1,1])\n",
    "    plot_vals['false']['confirmed targets'].append(conf_mat[0,1])\n",
    "    plot_vals['false']['eclipsing binaries'].append(conf_mat[1,0])"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 15,
   "metadata": {},
   "outputs": [],
   "source": [
    "from utils import *\n",
    "\n",
    "# Line plot each confidence matrix parameter\n",
    "x_data = [n_estimators, n_estimators, n_estimators, n_estimators]\n",
    "y_data = [plot_vals['true']['confirmed targets'],\n",
    "          plot_vals['true']['eclipsing binaries'],\n",
    "          plot_vals['false']['confirmed targets'],\n",
    "          plot_vals['false']['eclipsing binaries']]\n",
    "legends= ['True - C.T.', 'True - E.B.', 'False - C.T.', 'False - E.B.']\n",
    "colors = [6, 7, 2, 3]\n",
    "\n",
    "p = visual.multline_plot(x_data, y_data,\n",
    "                         legend_label=legends, \n",
    "                         title='Hyper parameter search - Confusion parameters plot',\n",
    "                         color_index=colors,\n",
    "                         y_axis={'label': 'Proportion'},\n",
    "                         x_axis={'label': 'n_estimators'})\n",
    "visual.show_plot(p)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "![Hyper parameter search - XGBoost Classifier - Naive Bayes](./images/nb_gallery/bokeh_plot(24).png)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "### Train model\n",
    "\n",
    "After running the hyper parameter search we can create a model with the best defined hyper parameters, or setup parameters, and consolidate the model in to the best version for further performance analysis. The model is saved on a particular variable, such as `bayes_clf` to be further used in some vote chain model, if further necessary."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 16,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "XGBClassifier(base_score=0.5, booster=None, colsample_bylevel=1,\n",
       "              colsample_bynode=1, colsample_bytree=1, gamma=0, gpu_id=-1,\n",
       "              importance_type='gain', interaction_constraints=None,\n",
       "              learning_rate=0.300000012, max_delta_step=0, max_depth=6,\n",
       "              min_child_weight=1, missing=nan, monotone_constraints=None,\n",
       "              n_estimators=11, n_jobs=0, num_parallel_tree=1,\n",
       "              objective='binary:logistic', random_state=0, reg_alpha=0,\n",
       "              reg_lambda=1, scale_pos_weight=1, subsample=1, tree_method=None,\n",
       "              validate_parameters=False, verbosity=0)"
      ]
     },
     "execution_count": 16,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "# XGBoost Classifier model parameters\n",
    "param_dist = {\n",
    "    'verbosity': 0,\n",
    "    'objective':'binary:logistic', \n",
    "    'n_estimators' : 11\n",
    "}\n",
    "\n",
    "# Create the model classifier\n",
    "bayes_clf = xgb.XGBClassifier(**param_dist)\n",
    "\n",
    "# Train the model\n",
    "bayes_clf.fit(X_train, y_train,\n",
    "              eval_set=[\n",
    "                (X_train, y_train), \n",
    "                (X_test, y_test)\n",
    "              ],\n",
    "              eval_metric='logloss',\n",
    "              verbose=False)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "### Results\n",
    "\n",
    "In this part it is presented the results from the classification algorithm. Both regarding the data visualization and the model classification quality. "
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 17,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "{ 'validation_0': { 'logloss': [ 0.567346,\n",
      "                                 0.456689,\n",
      "                                 0.383979,\n",
      "                                 0.341458,\n",
      "                                 0.312702,\n",
      "                                 0.277829,\n",
      "                                 0.251812,\n",
      "                                 0.232627,\n",
      "                                 0.216223,\n",
      "                                 0.202809,\n",
      "                                 0.194951]},\n",
      "  'validation_1': { 'logloss': [ 0.657235,\n",
      "                                 0.599724,\n",
      "                                 0.567681,\n",
      "                                 0.561523,\n",
      "                                 0.556633,\n",
      "                                 0.547125,\n",
      "                                 0.553211,\n",
      "                                 0.528883,\n",
      "                                 0.531398,\n",
      "                                 0.528597,\n",
      "                                 0.536761]}}\n"
     ]
    }
   ],
   "source": [
    "import pprint\n",
    "pp = pprint.PrettyPrinter(indent=2)\n",
    "\n",
    "pp.pprint(bayes_clf.evals_result())"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 18,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "image/png": "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\n",
      "text/plain": [
       "<Figure size 432x288 with 2 Axes>"
      ]
     },
     "metadata": {
      "needs_background": "light"
     },
     "output_type": "display_data"
    }
   ],
   "source": [
    "import matplotlib.pyplot as plt\n",
    "from sklearn.metrics import plot_confusion_matrix\n",
    "\n",
    "disp = plot_confusion_matrix(bayes_clf, X_test, y_test,\n",
    "                             display_labels=le_bayes.classes_,\n",
    "                             cmap=plt.cm.Blues,\n",
    "                             normalize='true')\n",
    "disp.ax_.set_title('Bayes Classifier - Confusion matrix')\n",
    "plt.show()"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "#### Comments\n",
    "\n",
    "*From this results it is possible to see that the classifier using Naive Bayes estimated model parameters is able to highly characterize the eclipsing binaries, and has acceptable classification performance for the confirmed targets. Also, the algorithm, as in the approach using the Periodograms, is highly consistent, due to the continuous descending loss during learning process for both the trainning and testing data. But comparing with the Periodogram approach, we can ensure that this one is much more simpler, considering the data preprocessing, than the one using the Periodograms. To generate the periodograms, several artesanal filtering techniques are necessary to generate the data in a suitable format for the machine learning model. Even considering that the classification performance is better then the Naive Bayes, more tests will be necessary to check if this better performace worth the trouble and stability risk of the preprocessing techniques.*"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "---\n",
    "\n",
    "## Hidden Markov Models\n",
    "\n",
    "Here we use the model estimated from the Hidden Markov Models library, wich is the estimated $A$ matrix, or the so called transition probability matrices as feature for the learning classifier. For that we must read the pickle file with the desired features:"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 19,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "dict_keys(['y', 't', 'labels', 'features'])"
      ]
     },
     "execution_count": 19,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "import pickle \n",
    "\n",
    "file_name = './features/hmm_data/nx_8/hmm_data.pkl'\n",
    "with open(file_name, 'rb') as file:\n",
    "    hmm_data = pickle.load(file)\n",
    "hmm_data.keys()"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "### Manipulate features\n",
    "\n",
    "After reading the data, it is necessary to create the classical regression structure model in the format $Y = f\\left(\\Theta, X\\right)$, normalize the feature data and encode any possible label data into numerical classes. This is just the preparation for the machine leaning algorithm to guarantee that the provided info is properlly designed for any machine learning classical form."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 20,
   "metadata": {},
   "outputs": [],
   "source": [
    "import numpy as np\n",
    "from sklearn import preprocessing\n",
    "\n",
    "# Encode the label\n",
    "le_hmm = preprocessing.LabelEncoder()\n",
    "le_hmm.fit( hmm_data['labels'] )\n",
    "\n",
    "# Define the model order\n",
    "feat = hmm_data['features']\n",
    "nx = feat['prob_matrix'][0].shape[0]\n",
    "\n",
    "regressors = []\n",
    "for phi in feat['prob_matrix']:\n",
    "    # Reshape the regressor\n",
    "    reg = phi.reshape(nx*nx)\n",
    "    # Add to the regressors\n",
    "    regressors.append(reg)   \n",
    "# Normalize the regressors\n",
    "regressors = preprocessing.normalize(regressors)\n",
    "# Define outputs as encoded variables\n",
    "outputs = le_hmm.transform(hmm_data['labels'])"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "### Train-test data split\n",
    "\n",
    "Next it is necessary to segregate the data into a set for validation and one for trainning the model."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 21,
   "metadata": {},
   "outputs": [],
   "source": [
    "from sklearn.model_selection import train_test_split\n",
    "\n",
    "X_train, X_test, y_train, y_test = train_test_split( \n",
    "    regressors, outputs, test_size=0.33, random_state=42)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "### Hyper tunning\n",
    "\n",
    "We could consider tunning the model hyper parameters to answer questions such as:\n",
    "\n",
    "- Wich value of `n_estimators` is the best for this model and data?\n",
    "- Wich cost function is the best to be selected as `objective` for this model?\n",
    "\n",
    "We could do a hyper search, to find the best hyper parameters for this model, automating the hyper parameter selection. There are several already builded algorithms to optimize this parameter search, and build find with high performance the best parameters, provided a set of possible values. But, to understand what those algorithms actually does, we could once build our own search algorithm...\n",
    "\n",
    "As an example, lets run a first handly defined hyper parameter tunning using the confusion matrix of the model:"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 22,
   "metadata": {},
   "outputs": [],
   "source": [
    "from sklearn.metrics import confusion_matrix\n",
    "\n",
    "n_estimators = [ k+1 for k in range(100)]\n",
    "\n",
    "conf_matrices = []\n",
    "for opt in n_estimators:\n",
    "    # Update the model parameters\n",
    "    param_dist['n_estimators'] = opt\n",
    "    # Create the xgBoost classifier\n",
    "    clfs = xgb.XGBClassifier(**param_dist)\n",
    "    # Fit the model to the data\n",
    "    clfs.fit(X_train, y_train,\n",
    "            eval_metric='logloss',\n",
    "            verbose=True)\n",
    "    # Estimate the test output\n",
    "    y_pred = clfs.predict(X_test)\n",
    "    # Compute the confusion matrix\n",
    "    conf_mat = confusion_matrix(\n",
    "        y_test, y_pred,\n",
    "        normalize='true')\n",
    "    # Save the confusion matrix\n",
    "    conf_matrices.append(conf_mat)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 23,
   "metadata": {},
   "outputs": [],
   "source": [
    "from utils import *\n",
    "\n",
    "# Create and organize the plot values\n",
    "plot_vals = {\n",
    "    'true': {\n",
    "        'confirmed targets': [],\n",
    "        'eclipsing binaries': [],\n",
    "    },\n",
    "    'false': {\n",
    "        'confirmed targets': [],\n",
    "        'eclipsing binaries': [],\n",
    "    }\n",
    "}\n",
    "for result in conf_matrices:\n",
    "    plot_vals['true']['confirmed targets'].append(result[0,0])\n",
    "    plot_vals['true']['eclipsing binaries'].append(result[1,1])\n",
    "    plot_vals['false']['confirmed targets'].append(result[0,1])\n",
    "    plot_vals['false']['eclipsing binaries'].append(result[1,0])\n",
    "\n",
    "x_values = range(len(conf_matrices))\n",
    "x_data = [x_values, x_values, x_values, x_values]\n",
    "y_data = [plot_vals['true']['confirmed targets'],\n",
    "          plot_vals['true']['eclipsing binaries'],\n",
    "          plot_vals['false']['confirmed targets'],\n",
    "          plot_vals['false']['eclipsing binaries']]\n",
    "legends= ['True - C.T.', 'True - E.B.', 'False - C.T.', 'False - E.B.']\n",
    "colors = [6, 7, 2, 3]\n",
    "\n",
    "p = visual.multline_plot(x_data, y_data,\n",
    "                         legend_label=legends, \n",
    "                         title='Hyper parameter search - Confusion plot',\n",
    "                         color_index=colors,\n",
    "                         y_axis={'label': 'Intensity'},\n",
    "                         x_axis={'label': 'n_estimators'})\n",
    "visual.show_plot(p)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "![Hyper parameter search - XGBoost Classifier - Hidden Markov Models](./images/nb_gallery/bokeh_plot(25).png)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "### Train model\n",
    "\n",
    "After running the hyper parameter search we can create a model with the best defined hyper parameters, or setup parameters, and consolidate the model in to the best version for further performance analysis. The model is saved on a particular variable, such as `hmm_clf` to be further used in some vote chain model, if further necessary."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 24,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "XGBClassifier(base_score=0.5, booster=None, colsample_bylevel=1,\n",
       "              colsample_bynode=1, colsample_bytree=1, gamma=0, gpu_id=-1,\n",
       "              importance_type='gain', interaction_constraints=None,\n",
       "              learning_rate=0.300000012, max_delta_step=0, max_depth=6,\n",
       "              min_child_weight=1, missing=nan, monotone_constraints=None,\n",
       "              n_estimators=34, n_jobs=0, num_parallel_tree=1,\n",
       "              objective='binary:logistic', random_state=0, reg_alpha=0,\n",
       "              reg_lambda=1, scale_pos_weight=1, subsample=1, tree_method=None,\n",
       "              validate_parameters=False, verbosity=0)"
      ]
     },
     "execution_count": 24,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "import xgboost as xgb\n",
    "\n",
    "param_dist = {\n",
    "    'verbosity': 0,\n",
    "    'objective':'binary:logistic', \n",
    "    'n_estimators' : 34\n",
    "}\n",
    "\n",
    "hmm_clf = xgb.XGBClassifier(**param_dist)\n",
    "\n",
    "hmm_clf.fit(X_train, y_train,\n",
    "            eval_set=[\n",
    "                (X_train, y_train), \n",
    "                (X_test, y_test)\n",
    "            ],\n",
    "            eval_metric='logloss',\n",
    "            verbose=False)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "### Results\n",
    "\n",
    "Here we include some visualization results for the xgBoost algorithm classification. As the first result, we just print the model eval metrics, here the *log loss* of the model, for both the trainning and testing data."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 25,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "{ 'validation_0': { 'logloss': [ 0.572305,\n",
      "                                 0.474664,\n",
      "                                 0.396965,\n",
      "                                 0.336296,\n",
      "                                 0.304903,\n",
      "                                 0.262527,\n",
      "                                 0.235207,\n",
      "                                 0.212948,\n",
      "                                 0.192356,\n",
      "                                 0.177346,\n",
      "                                 0.163549,\n",
      "                                 0.15337,\n",
      "                                 0.140518,\n",
      "                                 0.130899,\n",
      "                                 0.123485,\n",
      "                                 0.117721,\n",
      "                                 0.113933,\n",
      "                                 0.11041,\n",
      "                                 0.106786,\n",
      "                                 0.101635,\n",
      "                                 0.098872,\n",
      "                                 0.096439,\n",
      "                                 0.093749,\n",
      "                                 0.091741,\n",
      "                                 0.089836,\n",
      "                                 0.088826,\n",
      "                                 0.087047,\n",
      "                                 0.086091,\n",
      "                                 0.083466,\n",
      "                                 0.081756,\n",
      "                                 0.079948,\n",
      "                                 0.079189,\n",
      "                                 0.077326,\n",
      "                                 0.076633]},\n",
      "  'validation_1': { 'logloss': [ 0.673667,\n",
      "                                 0.635211,\n",
      "                                 0.618026,\n",
      "                                 0.607399,\n",
      "                                 0.628232,\n",
      "                                 0.650925,\n",
      "                                 0.654683,\n",
      "                                 0.651218,\n",
      "                                 0.653813,\n",
      "                                 0.663263,\n",
      "                                 0.660528,\n",
      "                                 0.677213,\n",
      "                                 0.667749,\n",
      "                                 0.663841,\n",
      "                                 0.676913,\n",
      "                                 0.67355,\n",
      "                                 0.675848,\n",
      "                                 0.674091,\n",
      "                                 0.687084,\n",
      "                                 0.693771,\n",
      "                                 0.69817,\n",
      "                                 0.700085,\n",
      "                                 0.69875,\n",
      "                                 0.69817,\n",
      "                                 0.688993,\n",
      "                                 0.692456,\n",
      "                                 0.697232,\n",
      "                                 0.699571,\n",
      "                                 0.694171,\n",
      "                                 0.6861,\n",
      "                                 0.6878,\n",
      "                                 0.690059,\n",
      "                                 0.682183,\n",
      "                                 0.685172]}}\n"
     ]
    }
   ],
   "source": [
    "import pprint\n",
    "pp = pprint.PrettyPrinter(indent=2)\n",
    "\n",
    "evals_result = hmm_clf.evals_result()\n",
    "pp.pprint(evals_result)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 26,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "image/png": "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\n",
      "text/plain": [
       "<Figure size 432x288 with 2 Axes>"
      ]
     },
     "metadata": {
      "needs_background": "light"
     },
     "output_type": "display_data"
    }
   ],
   "source": [
    "import matplotlib.pyplot as plt\n",
    "from sklearn.metrics import plot_confusion_matrix\n",
    "\n",
    "disp = plot_confusion_matrix(hmm_clf, X_test, y_test,\n",
    "                             display_labels=le_hmm.classes_,\n",
    "                             cmap=plt.cm.Blues,\n",
    "                             normalize='true')\n",
    "disp.ax_.set_title('Confusion matrix')\n",
    "plt.show()"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "#### Comments\n",
    "\n",
    "*This approch is far the worst one from the ones presented here. This is because, not only the preprocessing algorithms are to heavy and has several stability issues, the algorithm does not have a consistent and desired learning behavior for the test data, when considering the loss. Even though, the algorithm has a consistent classification performance on both classes, this other issues make these results also unstable, therefore it cannot be trusted.*"
   ]
  }
 ],
 "metadata": {
  "kernelspec": {
   "display_name": "Python 3",
   "language": "python",
   "name": "python3"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 3
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython3",
   "version": "3.7.4"
  }
 },
 "nbformat": 4,
 "nbformat_minor": 4
}
