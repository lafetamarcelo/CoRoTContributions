

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>Reading the data &mdash; CoRoT Contributions</title>
  

  
  
    <link rel="shortcut icon" href="_static/favicon.ico"/>
  
  
  

  
  <script type="text/javascript" src="_static/js/modernizr.min.js"></script>
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="./" src="_static/documentation_options.js"></script>
        <script src="_static/jquery.js"></script>
        <script src="_static/underscore.js"></script>
        <script src="_static/doctools.js"></script>
        <script src="_static/language_data.js"></script>
        <script src="_static/clipboard.min.js"></script>
        <script src="_static/copybutton.js"></script>
        <script crossorigin="anonymous" integrity="sha256-Ae2Vz/4ePdIu6ZyI/5ZGsYnb+m0JlOmKPjt6XZ9JJkA=" src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js"></script>
        <script async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
        <script type="text/x-mathjax-config">MathJax.Hub.Config({"tex2jax": {"inlineMath": [["$", "$"], ["\\(", "\\)"]], "processEscapes": true, "ignoreClass": "document", "processClass": "math|output_area"}})</script>
    
    <script type="text/javascript" src="_static/js/theme.js"></script>

    

  
  <link rel="stylesheet" href="_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="_static/copybutton.css" type="text/css" />
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="XGBoost Classifier" href="03 - Machine Learning - XGBoost Classifier.html" />
    <link rel="prev" title="Read .fits raw data" href="01 - Reading and Plotting.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="index.html" class="icon icon-home"> CoRoT Contributions
          

          
            
            <img src="_static/corot_logo.png" class="logo" alt="Logo"/>
          
          </a>

          
            
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <p class="caption"><span class="caption-text">Reading and Plotting</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="01 - Reading and Plotting.html">Read <em>.fits</em> raw data</a></li>
<li class="toctree-l1"><a class="reference internal" href="01 - Reading and Plotting.html#Preprocessing-data">Preprocessing data</a></li>
<li class="toctree-l1"><a class="reference internal" href="01 - Reading and Plotting.html#Resampling-series">Resampling series</a></li>
<li class="toctree-l1"><a class="reference internal" href="01 - Reading and Plotting.html#Filtering-series">Filtering series</a></li>
<li class="toctree-l1"><a class="reference internal" href="01 - Reading and Plotting.html#Application-example">Application example</a></li>
<li class="toctree-l1"><a class="reference internal" href="01 - Reading and Plotting.html#Generation-algorithms">Generation algorithms</a></li>
<li class="toctree-l1"><a class="reference internal" href="01 - Reading and Plotting.html#Save-pre-processed-data">Save pre-processed data</a></li>
</ul>
<p class="caption"><span class="caption-text">Feature Engineering</span></p>
<ul class="current">
<li class="toctree-l1 current"><a class="current reference internal" href="#">Reading the data</a></li>
<li class="toctree-l1"><a class="reference internal" href="#Feature:-Frequency-response">Feature: Frequency response</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#Introduction">Introduction</a></li>
<li class="toctree-l2"><a class="reference internal" href="#Spectrum-generation">Spectrum generation</a></li>
<li class="toctree-l2"><a class="reference internal" href="#Detrended-spectrum">Detrended spectrum</a></li>
<li class="toctree-l2"><a class="reference internal" href="#Resample-spectrum">Resample spectrum</a></li>
<li class="toctree-l2"><a class="reference internal" href="#Generation-algorithm">Generation algorithm</a></li>
<li class="toctree-l2"><a class="reference internal" href="#Save-feature">Save feature</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="#Feature:-Naive-Bayes-likelihood">Feature: Naive Bayes likelihood</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#Regression-model">Regression model</a></li>
<li class="toctree-l2"><a class="reference internal" href="#Next-step-parameters">Next step parameters</a></li>
<li class="toctree-l2"><a class="reference internal" href="#id1">Save feature</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="#Feature:-Markov-Hidden-Models">Feature: Markov Hidden Models</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#Preprocessing-data">Preprocessing data</a></li>
<li class="toctree-l2"><a class="reference internal" href="#Estimate-HMM">Estimate HMM</a></li>
<li class="toctree-l2"><a class="reference internal" href="#id2">Save feature</a></li>
<li class="toctree-l2"><a class="reference internal" href="#Download-features">Download features</a></li>
</ul>
</li>
</ul>
<p class="caption"><span class="caption-text">Machine Learning</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="03 - Machine Learning - XGBoost Classifier.html">XGBoost Classifier</a></li>
<li class="toctree-l1"><a class="reference internal" href="03 - Machine Learning - Decision Trees.html">Decision trees</a></li>
</ul>
<p class="caption"><span class="caption-text">Contents:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="modules.html">CoRoTContributions</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="index.html">CoRoT Contributions</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="index.html">Docs</a> &raquo;</li>
        
      <li>Reading the data</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
            <a href="_sources/02 - Building and creating features.ipynb.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  
<style>
/* CSS for nbsphinx extension */

/* remove conflicting styling from Sphinx themes */
div.nbinput.container,
div.nbinput.container div.prompt,
div.nbinput.container div.input_area,
div.nbinput.container div[class*=highlight],
div.nbinput.container div[class*=highlight] pre,
div.nboutput.container,
div.nboutput.container div.prompt,
div.nboutput.container div.output_area,
div.nboutput.container div[class*=highlight],
div.nboutput.container div[class*=highlight] pre {
    background: none;
    border: none;
    padding: 0 0;
    margin: 0;
    box-shadow: none;
}

/* avoid gaps between output lines */
div.nboutput.container div[class*=highlight] pre {
    line-height: normal;
}

/* input/output containers */
div.nbinput.container,
div.nboutput.container {
    display: -webkit-flex;
    display: flex;
    align-items: flex-start;
    margin: 0;
    width: 100%;
}
@media (max-width: 540px) {
    div.nbinput.container,
    div.nboutput.container {
        flex-direction: column;
    }
}

/* input container */
div.nbinput.container {
    padding-top: 5px;
}

/* last container */
div.nblast.container {
    padding-bottom: 5px;
}

/* input prompt */
div.nbinput.container div.prompt pre {
    color: #307FC1;
}

/* output prompt */
div.nboutput.container div.prompt pre {
    color: #BF5B3D;
}

/* all prompts */
div.nbinput.container div.prompt,
div.nboutput.container div.prompt {
    min-width: 5ex;
    padding-top: 0.3rem;
    padding-right: 0.3rem;
    text-align: right;
    flex: 0;
}
@media (max-width: 540px) {
    div.nbinput.container div.prompt,
    div.nboutput.container div.prompt {
        text-align: left;
        padding: 0.4em;
    }
    div.nboutput.container div.prompt.empty {
        padding: 0;
    }
}

/* disable scrollbars on prompts */
div.nbinput.container div.prompt pre,
div.nboutput.container div.prompt pre {
    overflow: hidden;
}

/* input/output area */
div.nbinput.container div.input_area,
div.nboutput.container div.output_area {
    -webkit-flex: 1;
    flex: 1;
    overflow: auto;
}
@media (max-width: 540px) {
    div.nbinput.container div.input_area,
    div.nboutput.container div.output_area {
        width: 100%;
    }
}

/* input area */
div.nbinput.container div.input_area {
    border: 1px solid #e0e0e0;
    border-radius: 2px;
    background: #f5f5f5;
}

/* override MathJax center alignment in output cells */
div.nboutput.container div[class*=MathJax] {
    text-align: left !important;
}

/* override sphinx.ext.imgmath center alignment in output cells */
div.nboutput.container div.math p {
    text-align: left;
}

/* standard error */
div.nboutput.container div.output_area.stderr {
    background: #fdd;
}

/* ANSI colors */
.ansi-black-fg { color: #3E424D; }
.ansi-black-bg { background-color: #3E424D; }
.ansi-black-intense-fg { color: #282C36; }
.ansi-black-intense-bg { background-color: #282C36; }
.ansi-red-fg { color: #E75C58; }
.ansi-red-bg { background-color: #E75C58; }
.ansi-red-intense-fg { color: #B22B31; }
.ansi-red-intense-bg { background-color: #B22B31; }
.ansi-green-fg { color: #00A250; }
.ansi-green-bg { background-color: #00A250; }
.ansi-green-intense-fg { color: #007427; }
.ansi-green-intense-bg { background-color: #007427; }
.ansi-yellow-fg { color: #DDB62B; }
.ansi-yellow-bg { background-color: #DDB62B; }
.ansi-yellow-intense-fg { color: #B27D12; }
.ansi-yellow-intense-bg { background-color: #B27D12; }
.ansi-blue-fg { color: #208FFB; }
.ansi-blue-bg { background-color: #208FFB; }
.ansi-blue-intense-fg { color: #0065CA; }
.ansi-blue-intense-bg { background-color: #0065CA; }
.ansi-magenta-fg { color: #D160C4; }
.ansi-magenta-bg { background-color: #D160C4; }
.ansi-magenta-intense-fg { color: #A03196; }
.ansi-magenta-intense-bg { background-color: #A03196; }
.ansi-cyan-fg { color: #60C6C8; }
.ansi-cyan-bg { background-color: #60C6C8; }
.ansi-cyan-intense-fg { color: #258F8F; }
.ansi-cyan-intense-bg { background-color: #258F8F; }
.ansi-white-fg { color: #C5C1B4; }
.ansi-white-bg { background-color: #C5C1B4; }
.ansi-white-intense-fg { color: #A1A6B2; }
.ansi-white-intense-bg { background-color: #A1A6B2; }

.ansi-default-inverse-fg { color: #FFFFFF; }
.ansi-default-inverse-bg { background-color: #000000; }

.ansi-bold { font-weight: bold; }
.ansi-underline { text-decoration: underline; }


div.nbinput.container div.input_area div[class*=highlight] > pre,
div.nboutput.container div.output_area div[class*=highlight] > pre,
div.nboutput.container div.output_area div[class*=highlight].math,
div.nboutput.container div.output_area.rendered_html,
div.nboutput.container div.output_area > div.output_javascript,
div.nboutput.container div.output_area:not(.rendered_html) > img{
    padding: 0.3rem;
}

/* fix copybtn overflow problem in chromium (needed for 'sphinx_copybutton') */
div.nbinput.container div.input_area > div[class^='highlight'],
div.nboutput.container div.output_area > div[class^='highlight']{
    overflow-y: hidden;
}

/* hide copybtn icon on prompts (needed for 'sphinx_copybutton') */
.prompt a.copybtn {
    display: none;
}

/* Some additional styling taken form the Jupyter notebook CSS */
div.rendered_html table {
  border: none;
  border-collapse: collapse;
  border-spacing: 0;
  color: black;
  font-size: 12px;
  table-layout: fixed;
}
div.rendered_html thead {
  border-bottom: 1px solid black;
  vertical-align: bottom;
}
div.rendered_html tr,
div.rendered_html th,
div.rendered_html td {
  text-align: right;
  vertical-align: middle;
  padding: 0.5em 0.5em;
  line-height: normal;
  white-space: normal;
  max-width: none;
  border: none;
}
div.rendered_html th {
  font-weight: bold;
}
div.rendered_html tbody tr:nth-child(odd) {
  background: #f5f5f5;
}
div.rendered_html tbody tr:hover {
  background: rgba(66, 165, 245, 0.2);
}

/* CSS overrides for sphinx_rtd_theme */

/* 24px margin */
.nbinput.nblast.container,
.nboutput.nblast.container {
    margin-bottom: 19px;  /* padding has already 5px */
}

/* ... except between code cells! */
.nblast.container + .nbinput.container {
    margin-top: -19px;
}

.admonition > p:before {
    margin-right: 4px;  /* make room for the exclamation icon */
}

/* Fix math alignment, see https://github.com/rtfd/sphinx_rtd_theme/pull/686 */
.math {
    text-align: unset;
}
</style>
<div class="section" id="Reading-the-data">
<h1>Reading the data<a class="headerlink" href="#Reading-the-data" title="Permalink to this headline">¶</a></h1>
<p>To go trough with this example, one might have or a</p>
<ul class="simple">
<li><p><em>filtered.pkl</em> - pickle format file</p></li>
<li><p><em>filtered.mat</em> - matlab format file</p></li>
</ul>
<p>as generated in the previous step of the pipeline. Note that, we are now ready to generate features for the machine learning algorithms. The biggest challenge is to get static features out of the time series (wich is a dynamic data). Here we will approach three main static feature generation paths:</p>
<ul class="simple">
<li><p>Frequency analysis with periodograms</p></li>
<li><p>Naive Bayes likelihood parameters</p></li>
<li><p>Markov transition probability matrix</p></li>
</ul>
<p>All of these three features will be further used as static data for the machine learning algorithms to learn how to classify the light curves as each class. So first, it is necessary to read the preprocessed/filtered data from the last pipeline step:</p>
<blockquote>
<div><p><em>Note that we must have the data preprocessed and labeled as exo-planets and not exo-planets. If the user does not have this file already, it just need to run follow trough the last pipeline step procedures, or one can download one version of the preprocessed data from:</em> - <a class="reference external" href="https://drive.google.com/drive/folders/19kALbQ5m1ppXxGTVMBaWA4KdIE9pmWfM?usp=sharing">Google drive access</a></p>
</div></blockquote>
<div class="nbinput nblast docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[1]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre>
<span></span><span class="kn">import</span> <span class="nn">pickle</span>

<span class="n">file_path</span> <span class="o">=</span> <span class="s1">&#39;./filtered.pkl&#39;</span>
<span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">file_path</span><span class="p">,</span> <span class="s1">&#39;rb&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
    <span class="n">curves</span> <span class="o">=</span> <span class="n">pickle</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
</pre></div>
</div>
</div>
<p>After, lets import the utils package with the support algorithms…</p>
<div class="nbinput docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[2]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre>
<span></span><span class="kn">from</span> <span class="nn">utils</span> <span class="kn">import</span> <span class="o">*</span>
</pre></div>
</div>
</div>
<div class="nboutput docutils container">
<div class="prompt empty docutils container">
</div>
<div class="output_area rendered_html docutils container">
<div class="bk-root">
    <a href="https://bokeh.org" target="_blank" class="bk-logo bk-logo-small bk-logo-notebook"></a>
    <span id="1001">Loading BokehJS ...</span>
</div></div>
</div>
<div class="nboutput nblast docutils container">
<div class="prompt empty docutils container">
</div>
<div class="output_area docutils container">
<div class="output_javascript"></div>
<script type="text/javascript">
var element = document.currentScript.previousSibling.previousSibling;

(function(root) {
  function now() {
    return new Date();
  }

  var force = true;

  if (typeof root._bokeh_onload_callbacks === "undefined" || force === true) {
    root._bokeh_onload_callbacks = [];
    root._bokeh_is_loading = undefined;
  }

  var JS_MIME_TYPE = 'application/javascript';
  var HTML_MIME_TYPE = 'text/html';
  var EXEC_MIME_TYPE = 'application/vnd.bokehjs_exec.v0+json';
  var CLASS_NAME = 'output_bokeh rendered_html';

  /**
   * Render data to the DOM node
   */
  function render(props, node) {
    var script = document.createElement("script");
    node.appendChild(script);
  }

  /**
   * Handle when an output is cleared or removed
   */
  function handleClearOutput(event, handle) {
    var cell = handle.cell;

    var id = cell.output_area._bokeh_element_id;
    var server_id = cell.output_area._bokeh_server_id;
    // Clean up Bokeh references
    if (id != null && id in Bokeh.index) {
      Bokeh.index[id].model.document.clear();
      delete Bokeh.index[id];
    }

    if (server_id !== undefined) {
      // Clean up Bokeh references
      var cmd = "from bokeh.io.state import curstate; print(curstate().uuid_to_server['" + server_id + "'].get_sessions()[0].document.roots[0]._id)";
      cell.notebook.kernel.execute(cmd, {
        iopub: {
          output: function(msg) {
            var id = msg.content.text.trim();
            if (id in Bokeh.index) {
              Bokeh.index[id].model.document.clear();
              delete Bokeh.index[id];
            }
          }
        }
      });
      // Destroy server and session
      var cmd = "import bokeh.io.notebook as ion; ion.destroy_server('" + server_id + "')";
      cell.notebook.kernel.execute(cmd);
    }
  }

  /**
   * Handle when a new output is added
   */
  function handleAddOutput(event, handle) {
    var output_area = handle.output_area;
    var output = handle.output;

    // limit handleAddOutput to display_data with EXEC_MIME_TYPE content only
    if ((output.output_type != "display_data") || (!output.data.hasOwnProperty(EXEC_MIME_TYPE))) {
      return
    }

    var toinsert = output_area.element.find("." + CLASS_NAME.split(' ')[0]);

    if (output.metadata[EXEC_MIME_TYPE]["id"] !== undefined) {
      toinsert[toinsert.length - 1].firstChild.textContent = output.data[JS_MIME_TYPE];
      // store reference to embed id on output_area
      output_area._bokeh_element_id = output.metadata[EXEC_MIME_TYPE]["id"];
    }
    if (output.metadata[EXEC_MIME_TYPE]["server_id"] !== undefined) {
      var bk_div = document.createElement("div");
      bk_div.innerHTML = output.data[HTML_MIME_TYPE];
      var script_attrs = bk_div.children[0].attributes;
      for (var i = 0; i < script_attrs.length; i++) {
        toinsert[toinsert.length - 1].firstChild.setAttribute(script_attrs[i].name, script_attrs[i].value);
        toinsert[toinsert.length - 1].firstChild.textContent = bk_div.children[0].textContent
      }
      // store reference to server id on output_area
      output_area._bokeh_server_id = output.metadata[EXEC_MIME_TYPE]["server_id"];
    }
  }

  function register_renderer(events, OutputArea) {

    function append_mime(data, metadata, element) {
      // create a DOM node to render to
      var toinsert = this.create_output_subarea(
        metadata,
        CLASS_NAME,
        EXEC_MIME_TYPE
      );
      this.keyboard_manager.register_events(toinsert);
      // Render to node
      var props = {data: data, metadata: metadata[EXEC_MIME_TYPE]};
      render(props, toinsert[toinsert.length - 1]);
      element.append(toinsert);
      return toinsert
    }

    /* Handle when an output is cleared or removed */
    events.on('clear_output.CodeCell', handleClearOutput);
    events.on('delete.Cell', handleClearOutput);

    /* Handle when a new output is added */
    events.on('output_added.OutputArea', handleAddOutput);

    /**
     * Register the mime type and append_mime function with output_area
     */
    OutputArea.prototype.register_mime_type(EXEC_MIME_TYPE, append_mime, {
      /* Is output safe? */
      safe: true,
      /* Index of renderer in `output_area.display_order` */
      index: 0
    });
  }

  // register the mime type if in Jupyter Notebook environment and previously unregistered
  if (root.Jupyter !== undefined) {
    var events = require('base/js/events');
    var OutputArea = require('notebook/js/outputarea').OutputArea;

    if (OutputArea.prototype.mime_types().indexOf(EXEC_MIME_TYPE) == -1) {
      register_renderer(events, OutputArea);
    }
  }


  if (typeof (root._bokeh_timeout) === "undefined" || force === true) {
    root._bokeh_timeout = Date.now() + 5000;
    root._bokeh_failed_load = false;
  }

  var NB_LOAD_WARNING = {'data': {'text/html':
     "<div style='background-color: #fdd'>\n"+
     "<p>\n"+
     "BokehJS does not appear to have successfully loaded. If loading BokehJS from CDN, this \n"+
     "may be due to a slow or bad network connection. Possible fixes:\n"+
     "</p>\n"+
     "<ul>\n"+
     "<li>re-rerun `output_notebook()` to attempt to load from CDN again, or</li>\n"+
     "<li>use INLINE resources instead, as so:</li>\n"+
     "</ul>\n"+
     "<code>\n"+
     "from bokeh.resources import INLINE\n"+
     "output_notebook(resources=INLINE)\n"+
     "</code>\n"+
     "</div>"}};

  function display_loaded() {
    var el = document.getElementById("1001");
    if (el != null) {
      el.textContent = "BokehJS is loading...";
    }
    if (root.Bokeh !== undefined) {
      if (el != null) {
        el.textContent = "BokehJS " + root.Bokeh.version + " successfully loaded.";
      }
    } else if (Date.now() < root._bokeh_timeout) {
      setTimeout(display_loaded, 100)
    }
  }


  function run_callbacks() {
    try {
      root._bokeh_onload_callbacks.forEach(function(callback) {
        if (callback != null)
          callback();
      });
    } finally {
      delete root._bokeh_onload_callbacks
    }
    console.debug("Bokeh: all callbacks have finished");
  }

  function load_libs(css_urls, js_urls, callback) {
    if (css_urls == null) css_urls = [];
    if (js_urls == null) js_urls = [];

    root._bokeh_onload_callbacks.push(callback);
    if (root._bokeh_is_loading > 0) {
      console.debug("Bokeh: BokehJS is being loaded, scheduling callback at", now());
      return null;
    }
    if (js_urls == null || js_urls.length === 0) {
      run_callbacks();
      return null;
    }
    console.debug("Bokeh: BokehJS not loaded, scheduling load and callback at", now());
    root._bokeh_is_loading = css_urls.length + js_urls.length;

    function on_load() {
      root._bokeh_is_loading--;
      if (root._bokeh_is_loading === 0) {
        console.debug("Bokeh: all BokehJS libraries/stylesheets loaded");
        run_callbacks()
      }
    }

    function on_error() {
      console.error("failed to load " + url);
    }

    for (var i = 0; i < css_urls.length; i++) {
      var url = css_urls[i];
      const element = document.createElement("link");
      element.onload = on_load;
      element.onerror = on_error;
      element.rel = "stylesheet";
      element.type = "text/css";
      element.href = url;
      console.debug("Bokeh: injecting link tag for BokehJS stylesheet: ", url);
      document.body.appendChild(element);
    }

    const hashes = {"https://cdn.bokeh.org/bokeh/release/bokeh-2.0.1.min.js": "JpP8FXbgAZLkfur7LiK3j9AGBhHNIvF742meBJrjO2ShJDhCG2I1uVvW+0DUtrmc", "https://cdn.bokeh.org/bokeh/release/bokeh-widgets-2.0.1.min.js": "xZlADit0Q04ISQEdKg2k3L4W9AwQBAuDs9nJL9fM/WwzL1tEU9VPNezOFX0nLEAz", "https://cdn.bokeh.org/bokeh/release/bokeh-tables-2.0.1.min.js": "4BuPRZkdMKSnj3zoxiNrQ86XgNw0rYmBOxe7nshquXwwcauupgBF2DHLVG1WuZlV", "https://cdn.bokeh.org/bokeh/release/bokeh-gl-2.0.1.min.js": "Dv1SQ87hmDqK6S5OhBf0bCuwAEvL5QYL0PuR/F1SPVhCS/r/abjkbpKDYL2zeM19"};

    for (var i = 0; i < js_urls.length; i++) {
      var url = js_urls[i];
      var element = document.createElement('script');
      element.onload = on_load;
      element.onerror = on_error;
      element.async = false;
      element.src = url;
      if (url in hashes) {
        element.crossOrigin = "anonymous";
        element.integrity = "sha384-" + hashes[url];
      }
      console.debug("Bokeh: injecting script tag for BokehJS library: ", url);
      document.head.appendChild(element);
    }
  };var element = document.getElementById("1001");
  if (element == null) {
    console.error("Bokeh: ERROR: autoload.js configured with elementid '1001' but no matching script tag was found. ")
    return false;
  }

  function inject_raw_css(css) {
    const element = document.createElement("style");
    element.appendChild(document.createTextNode(css));
    document.body.appendChild(element);
  }


  var js_urls = ["https://cdn.bokeh.org/bokeh/release/bokeh-2.0.1.min.js", "https://cdn.bokeh.org/bokeh/release/bokeh-widgets-2.0.1.min.js", "https://cdn.bokeh.org/bokeh/release/bokeh-tables-2.0.1.min.js", "https://cdn.bokeh.org/bokeh/release/bokeh-gl-2.0.1.min.js"];
  var css_urls = [];


  var inline_js = [
    function(Bokeh) {
      Bokeh.set_log_level("info");
    },
    function(Bokeh) {


    }
  ];

  function run_inline_js() {

    if (root.Bokeh !== undefined || force === true) {

    for (var i = 0; i < inline_js.length; i++) {
      inline_js[i].call(root, root.Bokeh);
    }
    if (force === true) {
        display_loaded();
      }} else if (Date.now() < root._bokeh_timeout) {
      setTimeout(run_inline_js, 100);
    } else if (!root._bokeh_failed_load) {
      console.log("Bokeh: BokehJS failed to load within specified timeout.");
      root._bokeh_failed_load = true;
    } else if (force !== true) {
      var cell = $(document.getElementById("1001")).parents('.cell').data().cell;
      cell.output_area.append_execute_result(NB_LOAD_WARNING)
    }

  }

  if (root._bokeh_is_loading === 0) {
    console.debug("Bokeh: BokehJS loaded, going straight to plotting");
    run_inline_js();
  } else {
    load_libs(css_urls, js_urls, function() {
      console.debug("Bokeh: BokehJS plotting callback run at", now());
      run_inline_js();
    });
  }
}(window));
</script></div>
</div>
<p>Just plot an example time series to get a notion on the data obtained from the pickle (<em>.pkl</em>) file generated from the previous study script, and for that the <code class="docutils literal notranslate"><span class="pre">utils</span></code> library will be imported to take advantage of its <code class="docutils literal notranslate"><span class="pre">visual</span></code> functionality:</p>
<div class="nbinput nblast docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[3]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre>
<span></span><span class="kn">from</span> <span class="nn">utils</span> <span class="kn">import</span> <span class="o">*</span>
<span class="kn">from</span> <span class="nn">datetime</span> <span class="kn">import</span> <span class="n">datetime</span>
<span class="kn">from</span> <span class="nn">datetime</span> <span class="kn">import</span> <span class="n">timedelta</span>

<span class="n">index</span> <span class="o">=</span> <span class="mi">8</span>

<span class="n">time_in_days</span> <span class="o">=</span> <span class="p">[</span><span class="n">curves</span><span class="p">[</span><span class="s1">&#39;i&#39;</span><span class="p">][</span><span class="n">index</span><span class="p">]</span>
                <span class="o">+</span> <span class="n">timedelta</span><span class="p">(</span><span class="n">minutes</span><span class="o">=</span><span class="n">time</span><span class="p">)</span> <span class="k">for</span> <span class="n">time</span> <span class="ow">in</span> <span class="n">curves</span><span class="p">[</span><span class="s1">&#39;t&#39;</span><span class="p">][</span><span class="n">index</span><span class="p">]]</span>

<span class="n">x_data</span> <span class="o">=</span> <span class="p">[</span><span class="n">time_in_days</span><span class="p">,</span> <span class="n">time_in_days</span><span class="p">]</span>
<span class="n">y_data</span> <span class="o">=</span> <span class="p">[</span><span class="n">curves</span><span class="p">[</span><span class="s1">&#39;r&#39;</span><span class="p">][</span><span class="n">index</span><span class="p">],</span> <span class="n">curves</span><span class="p">[</span><span class="s1">&#39;y&#39;</span><span class="p">][</span><span class="n">index</span><span class="p">]]</span>
<span class="n">legends</span><span class="o">=</span> <span class="p">[</span><span class="s1">&#39;Raw Light Curve&#39;</span><span class="p">,</span> <span class="s1">&#39;Filtered Light Curve&#39;</span><span class="p">]</span>
<span class="n">colors</span> <span class="o">=</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">5</span><span class="p">]</span>

<span class="n">p</span> <span class="o">=</span> <span class="n">visual</span><span class="o">.</span><span class="n">multline_plot</span><span class="p">(</span><span class="n">x_data</span><span class="p">,</span> <span class="n">y_data</span><span class="p">,</span>
                         <span class="n">legend_label</span><span class="o">=</span><span class="n">legends</span><span class="p">,</span>
                         <span class="n">title</span><span class="o">=</span><span class="s1">&#39;Light Curve Example&#39;</span><span class="p">,</span>
                         <span class="n">color_index</span><span class="o">=</span><span class="n">colors</span><span class="p">,</span>
                         <span class="n">y_axis</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;label&#39;</span><span class="p">:</span> <span class="s1">&#39;Intensity&#39;</span><span class="p">},</span>
                         <span class="n">x_axis</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;label&#39;</span><span class="p">:</span> <span class="s1">&#39;Date (m/dd)&#39;</span><span class="p">,</span>
                                 <span class="s1">&#39;type&#39;</span><span class="p">:</span> <span class="s1">&#39;datetime&#39;</span><span class="p">})</span>
<span class="n">visual</span><span class="o">.</span><span class="n">show_plot</span><span class="p">(</span><span class="n">p</span><span class="p">)</span>
</pre></div>
</div>
</div>
<p><img alt="Litgh curve example - filtered and raw" src="_images/bokeh_plot(10).png" /></p>
<p>Just for ilustration… lets see how much samples we have in each curve. This gives the notion on how much data there is in each curve. From that it is possible to realise how much time the next algorithms will take to generate the necessary information.</p>
<div class="nbinput nblast docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[4]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre>
<span></span><span class="n">sizes</span> <span class="o">=</span> <span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="n">curve</span><span class="p">)</span> <span class="k">for</span> <span class="n">curve</span> <span class="ow">in</span> <span class="n">curves</span><span class="p">[</span><span class="s1">&#39;y&#39;</span><span class="p">]]</span>
<span class="n">x_values</span> <span class="o">=</span> <span class="p">[</span><span class="n">k</span><span class="o">+</span><span class="mi">1</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">sizes</span><span class="p">))]</span>
<span class="n">sizes</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">reverse</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

<span class="n">p</span> <span class="o">=</span> <span class="n">visual</span><span class="o">.</span><span class="n">line_plot</span><span class="p">(</span><span class="n">x_values</span><span class="p">,</span> <span class="n">sizes</span><span class="p">,</span>
                     <span class="n">legend_label</span><span class="o">=</span><span class="s1">&#39;Dimensions&#39;</span><span class="p">,</span>
                     <span class="n">title</span><span class="o">=</span><span class="s1">&#39;Curves dimensions&#39;</span><span class="p">,</span>
                     <span class="n">color_index</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span>
                     <span class="n">y_axis</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;label&#39;</span><span class="p">:</span> <span class="s1">&#39;Sizes&#39;</span><span class="p">},</span>
                     <span class="n">x_axis</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;label&#39;</span><span class="p">:</span> <span class="s1">&#39;Curve index&#39;</span><span class="p">})</span>
<span class="n">visual</span><span class="o">.</span><span class="n">show_plot</span><span class="p">(</span><span class="n">p</span><span class="p">)</span>
</pre></div>
</div>
</div>
<p><img alt="Light curve sizes" src="_images/bokeh_plot(11).png" /></p>
<p>Compute some important constants that will be used during the analysis, such as mean sample time and sample frequency.</p>
<div class="nbinput docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[5]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre>
<span></span><span class="n">sample_time</span> <span class="o">=</span> <span class="n">curves</span><span class="p">[</span><span class="s1">&#39;t&#39;</span><span class="p">][</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">curves</span><span class="p">[</span><span class="s1">&#39;t&#39;</span><span class="p">][</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>   <span class="c1"># minutes</span>
<span class="n">sample_freq</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">/</span> <span class="p">(</span><span class="mi">60</span> <span class="o">*</span> <span class="n">sample_time</span><span class="p">)</span>                  <span class="c1"># hertz</span>

<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;The series have a time sample of </span><span class="si">{}</span><span class="s2"> minutes, consequently a sample frequency of </span><span class="si">{}</span><span class="s2"> Hz&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">round</span><span class="p">(</span><span class="n">sample_time</span><span class="p">,</span><span class="mi">2</span><span class="p">),</span> <span class="nb">round</span><span class="p">(</span><span class="n">sample_freq</span><span class="p">,</span><span class="mi">6</span><span class="p">)))</span>
</pre></div>
</div>
</div>
<div class="nboutput nblast docutils container">
<div class="prompt empty docutils container">
</div>
<div class="output_area docutils container">
<div class="highlight"><pre>
The series have a time sample of 8.56 minutes, consequently a sample frequency of 0.001946 Hz
</pre></div></div>
</div>
</div>
<div class="section" id="Feature:-Frequency-response">
<h1>Feature: Frequency response<a class="headerlink" href="#Feature:-Frequency-response" title="Permalink to this headline">¶</a></h1>
<hr class="docutils" />
<div class="section" id="Introduction">
<h2>Introduction<a class="headerlink" href="#Introduction" title="Permalink to this headline">¶</a></h2>
<p>One must know that theorically the most characteristic representation of a particular signal, would be its Fourier spectrum. If the real life signals were actually simple, it would be pretty simple to characterize those signals by their frequency spectrum. But unfortunately the real world signals are actully filled with noise from several natures.</p>
<p>So, if you want to get the most informative static information of a dynamic signal, it would be the power spectrum of this signal in the frequency domain without the undesired noise. In this chapter, it is developed an algorithm that attempt to find this representation for each light curve and adapt this information to be further used as features for machine learning algorithms.</p>
<hr class="docutils" />
<p>Select one curve to create the frequency analysis, let’s say the curve indexed as <code class="docutils literal notranslate"><span class="pre">index</span> <span class="pre">=</span> <span class="pre">5</span></code>. We use that curve as an example to create the routine to create time-series power spectrum feature for the machine learning algorithms. Later, a generation algorithm will be presented, which will properly reproduce this process for all handle light curves. For that matter, we first present the curve:</p>
<div class="nbinput nblast docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[6]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre>
<span></span><span class="n">index</span> <span class="o">=</span> <span class="mi">5</span>

<span class="n">time_in_days</span> <span class="o">=</span> <span class="p">[</span><span class="n">curves</span><span class="p">[</span><span class="s1">&#39;i&#39;</span><span class="p">][</span><span class="n">index</span><span class="p">]</span>
                <span class="o">+</span> <span class="n">timedelta</span><span class="p">(</span><span class="n">minutes</span><span class="o">=</span><span class="n">time</span><span class="p">)</span> <span class="k">for</span> <span class="n">time</span> <span class="ow">in</span> <span class="n">curves</span><span class="p">[</span><span class="s1">&#39;t&#39;</span><span class="p">][</span><span class="n">index</span><span class="p">]]</span>

<span class="n">x_data</span> <span class="o">=</span> <span class="p">[</span><span class="n">time_in_days</span><span class="p">,</span> <span class="n">time_in_days</span><span class="p">]</span>
<span class="n">y_data</span> <span class="o">=</span> <span class="p">[</span><span class="n">curves</span><span class="p">[</span><span class="s1">&#39;r&#39;</span><span class="p">][</span><span class="n">index</span><span class="p">],</span> <span class="n">curves</span><span class="p">[</span><span class="s1">&#39;y&#39;</span><span class="p">][</span><span class="n">index</span><span class="p">]]</span>
<span class="n">legends</span><span class="o">=</span> <span class="p">[</span><span class="s1">&#39;Raw Light Curve&#39;</span><span class="p">,</span> <span class="s1">&#39;Filtered Light Curve&#39;</span><span class="p">]</span>
<span class="n">colors</span> <span class="o">=</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">5</span><span class="p">]</span>

<span class="n">p</span> <span class="o">=</span> <span class="n">visual</span><span class="o">.</span><span class="n">multline_plot</span><span class="p">(</span><span class="n">x_data</span><span class="p">,</span> <span class="n">y_data</span><span class="p">,</span>
                         <span class="n">legend_label</span><span class="o">=</span><span class="n">legends</span><span class="p">,</span>
                         <span class="n">title</span><span class="o">=</span><span class="s1">&#39;Light Curve Example&#39;</span><span class="p">,</span>
                         <span class="n">color_index</span><span class="o">=</span><span class="n">colors</span><span class="p">,</span>
                         <span class="n">y_axis</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;label&#39;</span><span class="p">:</span> <span class="s1">&#39;Intensity&#39;</span><span class="p">},</span>
                         <span class="n">x_axis</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;label&#39;</span><span class="p">:</span> <span class="s1">&#39;Date (m/dd)&#39;</span><span class="p">,</span>
                                 <span class="s1">&#39;type&#39;</span><span class="p">:</span> <span class="s1">&#39;datetime&#39;</span><span class="p">})</span>
<span class="n">visual</span><span class="o">.</span><span class="n">show_plot</span><span class="p">(</span><span class="n">p</span><span class="p">)</span>
</pre></div>
</div>
</div>
<p><img alt="Another light curve example" src="_images/bokeh_plot(12).png" /></p>
</div>
<div class="section" id="Spectrum-generation">
<h2>Spectrum generation<a class="headerlink" href="#Spectrum-generation" title="Permalink to this headline">¶</a></h2>
<p>Then we can use the <code class="docutils literal notranslate"><span class="pre">signal</span></code> library from <code class="docutils literal notranslate"><span class="pre">scipy</span></code> to create the Periodogram or also called as the Spectrogram of this time series. We will create both the frequency information for the filtered signal, and the original data saved from the last analysis, just to highlight the information removed with the filtering technique.</p>
<blockquote>
<div><p><em>From here, one might see that the filtering technique applied on the last analysis, only remove high frequency compenents from the data. We don’t know yep if the removed information is important or not for future analysis with machine learning, therefore, both frequency responses will be saved as feature for further analysis.</em></p>
</div></blockquote>
<div class="nbinput nblast docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[7]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre>
<span></span><span class="kn">import</span> <span class="nn">scipy.signal</span> <span class="k">as</span> <span class="nn">ssg</span>

<span class="n">freq</span><span class="p">,</span> <span class="n">spectra</span> <span class="o">=</span> <span class="n">ssg</span><span class="o">.</span><span class="n">periodogram</span><span class="p">(</span><span class="n">curves</span><span class="p">[</span><span class="s1">&#39;r&#39;</span><span class="p">][</span><span class="n">index</span><span class="p">],</span>
                                <span class="n">fs</span><span class="o">=</span><span class="n">sample_freq</span><span class="p">,</span> <span class="n">scaling</span><span class="o">=</span><span class="s1">&#39;density&#39;</span><span class="p">)</span>
<span class="n">ffreq</span><span class="p">,</span> <span class="n">fspectra</span> <span class="o">=</span> <span class="n">ssg</span><span class="o">.</span><span class="n">periodogram</span><span class="p">(</span><span class="n">curves</span><span class="p">[</span><span class="s1">&#39;y&#39;</span><span class="p">][</span><span class="n">index</span><span class="p">],</span>
                                  <span class="n">fs</span><span class="o">=</span><span class="n">sample_freq</span><span class="p">,</span> <span class="n">scaling</span><span class="o">=</span><span class="s1">&#39;density&#39;</span><span class="p">)</span>
<span class="n">efreq</span><span class="p">,</span> <span class="n">espectra</span> <span class="o">=</span> <span class="n">ssg</span><span class="o">.</span><span class="n">periodogram</span><span class="p">(</span><span class="n">curves</span><span class="p">[</span><span class="s1">&#39;y&#39;</span><span class="p">][</span><span class="n">index</span><span class="p">]</span><span class="o">-</span><span class="n">curves</span><span class="p">[</span><span class="s1">&#39;r&#39;</span><span class="p">][</span><span class="n">index</span><span class="p">],</span>
                                  <span class="n">fs</span><span class="o">=</span><span class="n">sample_freq</span><span class="p">,</span> <span class="n">scaling</span><span class="o">=</span><span class="s1">&#39;density&#39;</span><span class="p">)</span>

<span class="n">x_data</span> <span class="o">=</span> <span class="p">[</span><span class="n">freq</span><span class="p">,</span> <span class="n">ffreq</span><span class="p">]</span>
<span class="n">y_data</span> <span class="o">=</span> <span class="p">[</span><span class="n">spectra</span><span class="p">,</span> <span class="n">fspectra</span><span class="p">]</span>
<span class="n">legends</span><span class="o">=</span> <span class="p">[</span><span class="s1">&#39;Raw LC Spectrum&#39;</span><span class="p">,</span> <span class="s1">&#39;Filtered LC Spectrum&#39;</span><span class="p">]</span>
<span class="n">colors</span> <span class="o">=</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">5</span><span class="p">]</span>

<span class="n">p</span> <span class="o">=</span> <span class="n">visual</span><span class="o">.</span><span class="n">multline_plot</span><span class="p">(</span><span class="n">x_data</span><span class="p">,</span> <span class="n">y_data</span><span class="p">,</span>
                         <span class="n">legend_label</span><span class="o">=</span><span class="n">legends</span><span class="p">,</span>
                         <span class="n">title</span><span class="o">=</span><span class="s1">&#39;Light Curve Frequency Spectrum&#39;</span><span class="p">,</span>
                         <span class="n">color_index</span><span class="o">=</span><span class="n">colors</span><span class="p">,</span>
                         <span class="n">y_axis</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;label&#39;</span><span class="p">:</span> <span class="s1">&#39;Magnitude&#39;</span><span class="p">},</span>
                         <span class="n">x_axis</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;label&#39;</span><span class="p">:</span> <span class="s1">&#39;Frequency (Hz)&#39;</span><span class="p">,</span>
                                 <span class="s1">&#39;type&#39;</span><span class="p">:</span> <span class="s1">&#39;log&#39;</span><span class="p">})</span>
<span class="n">p1</span> <span class="o">=</span> <span class="n">visual</span><span class="o">.</span><span class="n">line_plot</span><span class="p">(</span><span class="n">efreq</span><span class="p">,</span> <span class="n">espectra</span><span class="p">,</span>
                     <span class="n">legend_label</span><span class="o">=</span><span class="s1">&#39;Difference spectra&#39;</span><span class="p">,</span>
                     <span class="n">title</span><span class="o">=</span><span class="s1">&#39;Spectrum of the filtered out noise&#39;</span><span class="p">,</span>
                     <span class="n">color_index</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span>
                     <span class="n">y_axis</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;label&#39;</span><span class="p">:</span> <span class="s1">&#39;Magnitude&#39;</span><span class="p">},</span>
                     <span class="n">x_axis</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;label&#39;</span><span class="p">:</span> <span class="s1">&#39;Frequency (Hz)&#39;</span><span class="p">,</span>
                             <span class="s1">&#39;type&#39;</span><span class="p">:</span> <span class="s1">&#39;log&#39;</span><span class="p">})</span>

<span class="n">visual</span><span class="o">.</span><span class="n">show_plot</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">p1</span><span class="p">)</span>
</pre></div>
</div>
</div>
<p><img alt="Light curve spectrum - filtered and raw" src="_images/bokeh_plot(13).png" /> <img alt="Difference from light curve spectrum - filtered - raw" src="_images/bokeh_plot(14).png" /></p>
</div>
<div class="section" id="Detrended-spectrum">
<h2>Detrended spectrum<a class="headerlink" href="#Detrended-spectrum" title="Permalink to this headline">¶</a></h2>
<hr class="docutils" />
<p>But before generating the proposed feature for the machine learning, we must first present another possible process of the signal that might be relevant for further analysis. The DC level of the signal, usually represents the <span class="math notranslate nohighlight">\(0\)</span> Hz component of the frequency spectrum, and does not provide any dynamic meaningful information of the data. Therefore, it is common sence to first remove the so called trend that composes the DC level of the signal. This process is also called detrending of the
signal. And it is pretty simple to be applied using the <code class="docutils literal notranslate"><span class="pre">signal</span></code> library from <code class="docutils literal notranslate"><span class="pre">scipy</span></code>.</p>
<div class="nbinput nblast docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[8]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre>
<span></span><span class="kn">import</span> <span class="nn">scipy.signal</span> <span class="k">as</span> <span class="nn">ssg</span>

<span class="n">detrended_data</span> <span class="o">=</span> <span class="n">ssg</span><span class="o">.</span><span class="n">detrend</span><span class="p">(</span><span class="n">curves</span><span class="p">[</span><span class="s1">&#39;y&#39;</span><span class="p">][</span><span class="n">index</span><span class="p">],</span> <span class="nb">type</span><span class="o">=</span><span class="s1">&#39;linear&#39;</span><span class="p">)</span>

<span class="n">time_in_days</span> <span class="o">=</span> <span class="p">[</span><span class="n">curves</span><span class="p">[</span><span class="s1">&#39;i&#39;</span><span class="p">][</span><span class="n">index</span><span class="p">]</span>
                <span class="o">+</span> <span class="n">timedelta</span><span class="p">(</span><span class="n">minutes</span><span class="o">=</span><span class="n">time</span><span class="p">)</span> <span class="k">for</span> <span class="n">time</span> <span class="ow">in</span> <span class="n">curves</span><span class="p">[</span><span class="s1">&#39;t&#39;</span><span class="p">][</span><span class="n">index</span><span class="p">]]</span>

<span class="n">p</span> <span class="o">=</span> <span class="n">visual</span><span class="o">.</span><span class="n">line_plot</span><span class="p">(</span><span class="n">time_in_days</span><span class="p">,</span> <span class="n">curves</span><span class="p">[</span><span class="s1">&#39;y&#39;</span><span class="p">][</span><span class="n">index</span><span class="p">],</span>
                     <span class="n">legend_label</span><span class="o">=</span><span class="s1">&#39;Raw Light Curve&#39;</span><span class="p">,</span>
                     <span class="n">title</span><span class="o">=</span><span class="s1">&#39;Light Curve Raw&#39;</span><span class="p">,</span>
                     <span class="n">color_index</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span>
                     <span class="n">y_axis</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;label&#39;</span><span class="p">:</span> <span class="s1">&#39;Intensity&#39;</span><span class="p">},</span>
                     <span class="n">x_axis</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;label&#39;</span><span class="p">:</span> <span class="s1">&#39;Time (dd/mm/yy)&#39;</span><span class="p">})</span>
<span class="n">p1</span> <span class="o">=</span> <span class="n">visual</span><span class="o">.</span><span class="n">line_plot</span><span class="p">(</span><span class="n">time_in_days</span><span class="p">,</span> <span class="n">detrended_data</span><span class="p">,</span>
                     <span class="n">legend_label</span><span class="o">=</span><span class="s1">&#39;Detrended Light Curve&#39;</span><span class="p">,</span>
                     <span class="n">title</span><span class="o">=</span><span class="s1">&#39;Light Curve Detrended&#39;</span><span class="p">,</span>
                     <span class="n">color_index</span><span class="o">=</span><span class="mi">4</span><span class="p">,</span>
                     <span class="n">y_axis</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;label&#39;</span><span class="p">:</span> <span class="s1">&#39;Intensity&#39;</span><span class="p">},</span>
                     <span class="n">x_axis</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;label&#39;</span><span class="p">:</span> <span class="s1">&#39;Time (dd/mm/yy)&#39;</span><span class="p">})</span>
<span class="n">visual</span><span class="o">.</span><span class="n">show_plot</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">p1</span><span class="p">)</span>
</pre></div>
</div>
</div>
<p><img alt="Light curve before detrend" src="_images/bokeh_plot(15).png" /> <img alt="Light curve after detrend" src="_images/bokeh_plot(16).png" /></p>
<p>The influence on the periodogram can be shown by just generating once more the periodogram of the detrended signal and the previous one, with DC level influence.</p>
<div class="nbinput nblast docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[9]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre>
<span></span><span class="n">freq</span><span class="p">,</span> <span class="n">spectra</span> <span class="o">=</span> <span class="n">ssg</span><span class="o">.</span><span class="n">periodogram</span><span class="p">(</span><span class="n">curves</span><span class="p">[</span><span class="s1">&#39;y&#39;</span><span class="p">][</span><span class="n">index</span><span class="p">],</span> <span class="n">fs</span><span class="o">=</span><span class="n">sample_freq</span><span class="p">,</span> <span class="n">scaling</span><span class="o">=</span><span class="s1">&#39;spectrum&#39;</span><span class="p">)</span>
<span class="n">ffreq</span><span class="p">,</span> <span class="n">fspectra</span> <span class="o">=</span> <span class="n">ssg</span><span class="o">.</span><span class="n">periodogram</span><span class="p">(</span><span class="n">detrended_data</span><span class="p">,</span> <span class="n">fs</span><span class="o">=</span><span class="n">sample_freq</span><span class="p">,</span> <span class="n">scaling</span><span class="o">=</span><span class="s1">&#39;spectrum&#39;</span><span class="p">)</span>
<span class="n">efreq</span><span class="p">,</span> <span class="n">espectra</span> <span class="o">=</span> <span class="n">ssg</span><span class="o">.</span><span class="n">periodogram</span><span class="p">(</span><span class="n">detrended_data</span><span class="o">-</span><span class="n">curves</span><span class="p">[</span><span class="s1">&#39;y&#39;</span><span class="p">][</span><span class="n">index</span><span class="p">],</span> <span class="n">fs</span><span class="o">=</span><span class="n">sample_freq</span><span class="p">,</span> <span class="n">scaling</span><span class="o">=</span><span class="s1">&#39;spectrum&#39;</span><span class="p">)</span>

<span class="n">x_data</span> <span class="o">=</span> <span class="p">[</span><span class="n">freq</span><span class="p">,</span> <span class="n">ffreq</span><span class="p">]</span>
<span class="n">y_data</span> <span class="o">=</span> <span class="p">[</span><span class="n">spectra</span><span class="p">,</span> <span class="n">fspectra</span><span class="p">]</span>
<span class="n">legends</span><span class="o">=</span> <span class="p">[</span><span class="s1">&#39;Raw LC Spectrum&#39;</span><span class="p">,</span> <span class="s1">&#39;Detrended LC Spectrum&#39;</span><span class="p">]</span>
<span class="n">colors</span> <span class="o">=</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">5</span><span class="p">]</span>

<span class="n">p</span> <span class="o">=</span> <span class="n">visual</span><span class="o">.</span><span class="n">multline_plot</span><span class="p">(</span><span class="n">x_data</span><span class="p">,</span> <span class="n">y_data</span><span class="p">,</span>
                         <span class="n">legend_label</span><span class="o">=</span><span class="n">legends</span><span class="p">,</span>
                         <span class="n">title</span><span class="o">=</span><span class="s1">&#39;Light Curve Spectrum&#39;</span><span class="p">,</span>
                         <span class="n">color_index</span><span class="o">=</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">5</span><span class="p">],</span>
                         <span class="n">y_axis</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;label&#39;</span><span class="p">:</span> <span class="s1">&#39;Magnitude&#39;</span><span class="p">},</span>
                         <span class="n">x_axis</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;label&#39;</span><span class="p">:</span> <span class="s1">&#39;Frequency (Hz)&#39;</span><span class="p">,</span>
                                 <span class="s1">&#39;type&#39;</span><span class="p">:</span> <span class="s1">&#39;log&#39;</span><span class="p">})</span>
<span class="n">p1</span> <span class="o">=</span> <span class="n">visual</span><span class="o">.</span><span class="n">line_plot</span><span class="p">(</span><span class="n">efreq</span><span class="p">,</span> <span class="n">espectra</span><span class="p">,</span>
                     <span class="n">legend_label</span><span class="o">=</span><span class="s1">&#39;LC Difference Spectrum&#39;</span><span class="p">,</span>
                     <span class="n">title</span><span class="o">=</span><span class="s1">&#39;Difference Spectrum&#39;</span><span class="p">,</span>
                     <span class="n">color_index</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span>
                     <span class="n">y_axis</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;label&#39;</span><span class="p">:</span> <span class="s1">&#39;Magnitude&#39;</span><span class="p">},</span>
                     <span class="n">x_axis</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;label&#39;</span><span class="p">:</span> <span class="s1">&#39;Frequency (Hz)&#39;</span><span class="p">,</span>
                             <span class="s1">&#39;type&#39;</span><span class="p">:</span> <span class="s1">&#39;log&#39;</span><span class="p">})</span>
<span class="n">visual</span><span class="o">.</span><span class="n">show_plot</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">p1</span><span class="p">)</span>
</pre></div>
</div>
</div>
<p><img alt="Spectrum before detrend" src="_images/bokeh_plot(17).png" /> <img alt="Spectrum after detrend" src="_images/bokeh_plot(18).png" /></p>
<p>Interesting enough, this is the spectrum of the time series analysed (<code class="docutils literal notranslate"><span class="pre">index=5</span></code>). Of course we will detect several highly evidenced frequency components, because the time series is clearly periodic. That is the most informative data that we could get from this time series using signal and dynamic systems theory.</p>
<blockquote>
<div><p><em>One might see that the information removed by using the detrend technique only removes low frequency information in a smooth way. It is necessary to be carreful when using filtering tehcniques, so that no nonlinear and aggressive techniques are applied to the data. Those aggressive techniques are usually not practical and might result on unreal phenomenon on the data.</em></p>
</div></blockquote>
</div>
<hr class="docutils" />
<div class="section" id="Resample-spectrum">
<h2>Resample spectrum<a class="headerlink" href="#Resample-spectrum" title="Permalink to this headline">¶</a></h2>
<p>One might notice that the spectrogram will not have the same resolution for each feature… This is the biggest problem on computing the time series power spectrum: the dimension inconsitency produced by the computation techniques to craft the power spectrum. Usually those algorithms rely on time series windows (remember the convolution process) to estimate the parameters of the Fourier representation of the series. Each time series has a particular number of samples and windows sizes with their
sweep space, and those controls the build power spectrum resolution. Because of this, each light curve will have a particular power spectrum resolution.</p>
<p>It is therefore, necessary to create an algorithm able to reshape or resample those power spectrum to an unique resolution. This is necessary because most machine learning algorithms only deal with constant feature dimensions. To achieve this goal, it is introduced the <code class="docutils literal notranslate"><span class="pre">resample_freq_data</span></code> function.</p>
<div class="nbinput nblast docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[10]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre>
<span></span><span class="kn">import</span> <span class="nn">scipy.signal</span> <span class="k">as</span> <span class="nn">ssg</span>
<span class="kn">from</span> <span class="nn">PyAstronomy</span> <span class="kn">import</span> <span class="n">pyasl</span>

<span class="k">def</span> <span class="nf">resample_freq_data</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                       <span class="n">upper_sample</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                       <span class="n">window</span><span class="o">=</span><span class="mi">13</span><span class="p">,</span>
                       <span class="n">algorithm</span><span class="o">=</span><span class="s1">&#39;hamming&#39;</span><span class="p">):</span>
    <span class="n">output_data</span> <span class="o">=</span> <span class="nb">list</span><span class="p">()</span>
    <span class="c1"># Get the maximun and minimun frequencies, and</span>
    <span class="c1"># the resolution of each feature</span>
    <span class="n">fmax</span><span class="p">,</span> <span class="n">fmin</span><span class="p">,</span> <span class="n">size</span> <span class="o">=</span> <span class="p">[],</span> <span class="p">[],</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">feat</span> <span class="ow">in</span> <span class="n">data</span><span class="p">[</span><span class="s1">&#39;freq&#39;</span><span class="p">]:</span>
        <span class="n">fmax</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">feat</span><span class="o">.</span><span class="n">max</span><span class="p">())</span>
        <span class="n">fmin</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">feat</span><span class="o">.</span><span class="n">min</span><span class="p">())</span>
        <span class="n">size</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">feat</span><span class="p">))</span>
    <span class="c1"># Compute the high and low resolution step for</span>
    <span class="c1"># the resampling</span>
    <span class="n">high_step</span> <span class="o">=</span> <span class="p">(</span><span class="nb">max</span><span class="p">(</span><span class="n">fmax</span><span class="p">)</span> <span class="o">-</span> <span class="nb">min</span><span class="p">(</span><span class="n">fmin</span><span class="p">))</span> <span class="o">/</span> <span class="nb">max</span><span class="p">(</span><span class="n">size</span><span class="p">)</span> <span class="c1"># high resolution</span>
    <span class="n">low_step</span> <span class="o">=</span> <span class="p">(</span><span class="nb">max</span><span class="p">(</span><span class="n">fmax</span><span class="p">)</span> <span class="o">-</span> <span class="nb">min</span><span class="p">(</span><span class="n">fmin</span><span class="p">))</span> <span class="o">/</span> <span class="nb">min</span><span class="p">(</span><span class="n">size</span><span class="p">)</span>  <span class="c1"># low resolution</span>
    <span class="c1"># Define the cutoff frequency to limit the</span>
    <span class="c1"># spectrum data set, adn compute the new</span>
    <span class="c1"># signal resolution based on the steps</span>
    <span class="n">up_cut_freq</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">fmax</span><span class="p">)</span>
    <span class="n">down_cut_frea</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">fmin</span><span class="p">)</span>
    <span class="n">high_resolution</span> <span class="o">=</span> <span class="n">up_cut_freq</span> <span class="o">/</span> <span class="n">high_step</span>
    <span class="n">low_resolution</span> <span class="o">=</span> <span class="n">up_cut_freq</span> <span class="o">/</span> <span class="n">low_step</span>
    <span class="c1"># Compute the resample of each feature</span>
    <span class="n">compact</span> <span class="o">=</span> <span class="nb">zip</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="s1">&#39;spec&#39;</span><span class="p">],</span> <span class="n">data</span><span class="p">[</span><span class="s1">&#39;freq&#39;</span><span class="p">])</span>
    <span class="k">for</span> <span class="n">spec</span><span class="p">,</span> <span class="n">freq</span> <span class="ow">in</span> <span class="n">compact</span><span class="p">:</span>
        <span class="c1"># Find the closest index to the cut</span>
        <span class="c1"># off freq, to remove the information</span>
        <span class="n">uspec</span><span class="p">,</span> <span class="n">ufreq</span> <span class="o">=</span> <span class="n">spec</span><span class="p">,</span> <span class="n">freq</span>
        <span class="k">if</span> <span class="nb">max</span><span class="p">(</span><span class="n">freq</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">up_cut_freq</span><span class="p">:</span>
            <span class="n">freq_diff</span> <span class="o">=</span> <span class="p">[</span><span class="nb">abs</span><span class="p">(</span><span class="n">f</span> <span class="o">-</span> <span class="n">up_cut_freq</span><span class="p">)</span> <span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="n">freq</span><span class="p">]</span>
            <span class="n">cut_index</span> <span class="o">=</span> <span class="n">freq_diff</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="nb">min</span><span class="p">(</span><span class="n">freq_diff</span><span class="p">))</span>
            <span class="n">uspec</span> <span class="o">=</span> <span class="n">spec</span><span class="p">[:</span><span class="n">cut_index</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span>
        <span class="c1"># Compute the resampled signal for</span>
        <span class="c1"># high or low resolution</span>
        <span class="k">if</span> <span class="n">upper_sample</span><span class="p">:</span>
            <span class="n">sig_size</span> <span class="o">=</span> <span class="nb">round</span><span class="p">(</span><span class="n">high_resolution</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">sig_size</span> <span class="o">=</span> <span class="nb">round</span><span class="p">(</span><span class="n">low_resolution</span><span class="p">)</span>
        <span class="c1"># Resample the spectrum</span>
        <span class="n">uspec</span> <span class="o">=</span> <span class="n">ssg</span><span class="o">.</span><span class="n">resample</span><span class="p">(</span><span class="n">uspec</span><span class="p">,</span> <span class="nb">int</span><span class="p">(</span><span class="n">sig_size</span><span class="p">))</span>
        <span class="c1"># Smooth the resampled spectrum</span>
        <span class="n">uspec</span> <span class="o">=</span> <span class="n">pyasl</span><span class="o">.</span><span class="n">smooth</span><span class="p">(</span><span class="n">uspec</span><span class="p">,</span> <span class="n">window</span><span class="p">,</span> <span class="n">algorithm</span><span class="p">)</span>
        <span class="c1"># Save the info into the output signal</span>
        <span class="n">output_data</span><span class="o">.</span><span class="n">append</span><span class="p">(</span> <span class="n">uspec</span><span class="p">[:</span><span class="o">-</span><span class="mi">10</span><span class="p">]</span> <span class="p">)</span>
    <span class="k">return</span> <span class="n">output_data</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="Generation-algorithm">
<h2>Generation algorithm<a class="headerlink" href="#Generation-algorithm" title="Permalink to this headline">¶</a></h2>
<p>Lets run all the preprocessing for all the light curve time series, and build the feature variable to be saved for the machine learning step of the pipeline:</p>
<div class="nbinput nblast docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[11]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre>
<span></span><span class="n">detrend</span> <span class="o">=</span> <span class="kc">True</span>
<span class="n">filtered</span> <span class="o">=</span> <span class="kc">True</span>

<span class="c1"># Detrend and filter all light curve</span>
<span class="c1"># time series data</span>
<span class="n">size</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">curves</span><span class="p">[</span><span class="s1">&#39;r&#39;</span><span class="p">])</span>
<span class="n">aux_data</span> <span class="o">=</span> <span class="p">{</span>
    <span class="s1">&#39;freq&#39;</span><span class="p">:</span> <span class="p">[],</span>
    <span class="s1">&#39;spec&#39;</span><span class="p">:</span> <span class="p">[]</span>
<span class="p">}</span>
<span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">size</span><span class="p">):</span>
    <span class="c1"># If we want a filtered data</span>
    <span class="k">if</span> <span class="n">filtered</span><span class="p">:</span>
        <span class="n">data</span> <span class="o">=</span> <span class="n">curves</span><span class="p">[</span><span class="s1">&#39;y&#39;</span><span class="p">][</span><span class="n">item</span><span class="p">]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">data</span> <span class="o">=</span> <span class="n">curves</span><span class="p">[</span><span class="s1">&#39;r&#39;</span><span class="p">][</span><span class="n">item</span><span class="p">]</span>
    <span class="c1"># If we want a detrended data</span>
    <span class="k">if</span> <span class="n">detrend</span><span class="p">:</span>
        <span class="n">data</span> <span class="o">=</span> <span class="n">ssg</span><span class="o">.</span><span class="n">detrend</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="nb">type</span><span class="o">=</span><span class="s1">&#39;linear&#39;</span><span class="p">)</span>
    <span class="c1"># Create the periodogram</span>
    <span class="n">freq</span><span class="p">,</span> <span class="n">spec</span> <span class="o">=</span> <span class="n">ssg</span><span class="o">.</span><span class="n">periodogram</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">fs</span><span class="o">=</span><span class="n">sample_freq</span><span class="p">,</span> <span class="n">scaling</span><span class="o">=</span><span class="s1">&#39;spectrum&#39;</span><span class="p">)</span>
    <span class="c1"># Save on the current variable</span>
    <span class="n">aux_data</span><span class="p">[</span><span class="s1">&#39;freq&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span> <span class="n">freq</span> <span class="p">)</span>
    <span class="n">aux_data</span><span class="p">[</span><span class="s1">&#39;spec&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span> <span class="n">spec</span> <span class="p">)</span>

<span class="c1"># Build the machine learning data</span>
<span class="c1"># structure to be saved on pickle file</span>
<span class="n">ml_data</span> <span class="o">=</span> <span class="p">{</span>
    <span class="s1">&#39;features&#39;</span><span class="p">:</span> <span class="p">{</span>
        <span class="s1">&#39;spec&#39;</span><span class="p">:</span> <span class="n">resample_freq_data</span><span class="p">(</span><span class="n">aux_data</span><span class="p">,</span><span class="n">window</span><span class="o">=</span><span class="mi">23</span><span class="p">)</span>
    <span class="p">},</span>
    <span class="s1">&#39;labels&#39;</span><span class="p">:</span> <span class="n">curves</span><span class="p">[</span><span class="s1">&#39;lab&#39;</span><span class="p">]</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<p>Just to guarantee the quality of the resampled variables, lets just plot the resampled one and the original spectrums</p>
<div class="nbinput nblast docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[12]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre>
<span></span><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>

<span class="n">index_plot</span> <span class="o">=</span> <span class="mi">15</span>

<span class="c1"># Resample the frequency data</span>
<span class="n">resolution</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">ml_data</span><span class="p">[</span><span class="s1">&#39;features&#39;</span><span class="p">][</span><span class="s1">&#39;spec&#39;</span><span class="p">][</span><span class="n">index_plot</span><span class="p">])</span>
<span class="n">init</span> <span class="o">=</span> <span class="n">aux_data</span><span class="p">[</span><span class="s1">&#39;freq&#39;</span><span class="p">][</span><span class="n">index_plot</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
<span class="n">final</span> <span class="o">=</span> <span class="n">aux_data</span><span class="p">[</span><span class="s1">&#39;freq&#39;</span><span class="p">][</span><span class="n">index_plot</span><span class="p">][</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
<span class="n">rfreq</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="n">init</span><span class="p">,</span> <span class="n">final</span><span class="p">,</span> <span class="n">resolution</span><span class="p">)</span>

<span class="c1"># Create the plot data</span>
<span class="n">x_data</span> <span class="o">=</span> <span class="p">[</span><span class="n">aux_data</span><span class="p">[</span><span class="s1">&#39;freq&#39;</span><span class="p">][</span><span class="n">index_plot</span><span class="p">],</span> <span class="n">rfreq</span><span class="p">]</span>
<span class="n">y_data</span> <span class="o">=</span> <span class="p">[</span><span class="n">aux_data</span><span class="p">[</span><span class="s1">&#39;spec&#39;</span><span class="p">][</span><span class="n">index_plot</span><span class="p">],</span> <span class="n">ml_data</span><span class="p">[</span><span class="s1">&#39;features&#39;</span><span class="p">][</span><span class="s1">&#39;spec&#39;</span><span class="p">][</span><span class="n">index_plot</span><span class="p">]]</span>
<span class="n">legends</span><span class="p">,</span> <span class="n">colors</span><span class="p">,</span> <span class="n">lw</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;Original&#39;</span><span class="p">,</span> <span class="s1">&#39;Resampled&#39;</span><span class="p">],</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">8</span><span class="p">],</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">2</span><span class="p">]</span>

<span class="n">p</span> <span class="o">=</span> <span class="n">visual</span><span class="o">.</span><span class="n">multline_plot</span><span class="p">(</span><span class="n">x_data</span><span class="p">,</span> <span class="n">y_data</span><span class="p">,</span>
                     <span class="n">legend_label</span><span class="o">=</span><span class="n">legends</span><span class="p">,</span>
                     <span class="n">title</span><span class="o">=</span><span class="s1">&#39;Spectrum validation&#39;</span><span class="p">,</span>
                     <span class="n">color_index</span><span class="o">=</span><span class="n">colors</span><span class="p">,</span>
                     <span class="n">line_width</span><span class="o">=</span><span class="n">lw</span><span class="p">,</span>
                     <span class="n">y_axis</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;label&#39;</span><span class="p">:</span> <span class="s1">&#39;Magnitude&#39;</span><span class="p">},</span>
                     <span class="n">x_axis</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;label&#39;</span><span class="p">:</span> <span class="s1">&#39;Frequency (Hz)&#39;</span><span class="p">,</span>
                             <span class="s1">&#39;type&#39;</span><span class="p">:</span> <span class="s1">&#39;log&#39;</span><span class="p">})</span>

<span class="n">visual</span><span class="o">.</span><span class="n">show_plot</span><span class="p">(</span><span class="n">p</span><span class="p">)</span>
</pre></div>
</div>
</div>
<p><img alt="Resampled spectrum" src="_images/bokeh_plot(19).png" /></p>
</div>
<div class="section" id="Save-feature">
<h2>Save feature<a class="headerlink" href="#Save-feature" title="Permalink to this headline">¶</a></h2>
<p>Here we will modify the feature in a way to be ready for machine learning algorithm take this information as features and labels.</p>
<div class="nbinput nblast docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[ ]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre>
<span></span><span class="n">file_name</span> <span class="o">=</span> <span class="s1">&#39;./features/freq_data/freq_data.pkl&#39;</span>

<span class="n">output</span> <span class="o">=</span> <span class="nb">open</span><span class="p">(</span><span class="n">file_name</span><span class="p">,</span> <span class="s1">&#39;wb&#39;</span><span class="p">)</span>
<span class="n">pickle</span><span class="o">.</span><span class="n">dump</span><span class="p">(</span><span class="n">ml_data</span><span class="p">,</span> <span class="n">output</span><span class="p">)</span>
<span class="n">output</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
</pre></div>
</div>
</div>
</div>
</div>
<div class="section" id="Feature:-Naive-Bayes-likelihood">
<h1>Feature: Naive Bayes likelihood<a class="headerlink" href="#Feature:-Naive-Bayes-likelihood" title="Permalink to this headline">¶</a></h1>
<hr class="docutils" />
<p>To create the Naive Bayes marginal likelihood approach, we just will try to use the bayesian theory for optimal filtering. The main structure here used will be the Bayes Ridge Regression, from the <code class="docutils literal notranslate"><span class="pre">sklearn</span></code> library. The main idea is to create a regression based model for each curve, and use the estimated parameters of each model as feature for machine learning classification. The regression model can be represented as</p>
<div class="math notranslate nohighlight">
\[p(y |X,\omega, \alpha) = \mathcal{N}(y|X\omega,\alpha)\]</div>
<p>In the ridge regression, is assumed the prior value for the cofficient <span class="math notranslate nohighlight">\(\omega\)</span> to be given by a spherical Gaussian, leading the regression problem to be mapped as</p>
<div class="math notranslate nohighlight">
\[p(\omega |\lambda) = \mathcal{N}(\omega|0,\lambda^{-1}I_p)\]</div>
<p>The model estimation is just a matter of finding the set of <span class="math notranslate nohighlight">\(\omega\)</span>, that minimizes the <span class="math notranslate nohighlight">\(\mathcal{l}_2\)</span> norm for a provided user defined parameter <span class="math notranslate nohighlight">\(\lambda\)</span>. The <span class="math notranslate nohighlight">\(\omega\)</span> values are the most characteristic information of each light curve. Thence, here we use those values as features to train the classifier to cluster the light curve classes.</p>
<p>There are some discussions that one might include for this approach. One might ask:</p>
<ul class="simple">
<li><p>What question should the bayes alorithm answer?</p></li>
<li><p>It will be just a regression model pro predict the next step?</p></li>
<li><p>It will be a regression model to predict model tendencies?</p></li>
</ul>
<p>The best answer for that will appear when one uses the features provided from each path taken to try to classify the model. We cannot say before hand what feature will be best or not… Therefore, we must create some fetaure and then use their information to try to cluster the curve data.</p>
<div class="section" id="Regression-model">
<h2>Regression model<a class="headerlink" href="#Regression-model" title="Permalink to this headline">¶</a></h2>
<p>In both approaches is necessary to create a regression model, with chosen order <span class="math notranslate nohighlight">\(n_x\)</span>. To do that, one can use a function such as this:</p>
<div class="nbinput nblast docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[13]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre>
<span></span><span class="k">def</span> <span class="nf">build_regressor</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="mi">6</span><span class="p">,</span> <span class="n">norm</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
    <span class="n">nx</span> <span class="o">=</span> <span class="n">order</span>
    <span class="n">outputs</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">regressors</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">curve</span> <span class="ow">in</span> <span class="n">data</span><span class="p">:</span>
        <span class="n">phi</span><span class="p">,</span> <span class="n">y</span> <span class="o">=</span> <span class="p">[],</span> <span class="p">[]</span>
        <span class="n">size</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">curve</span><span class="p">)</span>
        <span class="c1"># Normalize the curve data</span>
        <span class="n">serie</span> <span class="o">=</span> <span class="n">curve</span>
        <span class="k">if</span> <span class="n">norm</span><span class="p">:</span>
            <span class="n">serie</span> <span class="o">=</span> <span class="p">(</span><span class="n">curve</span> <span class="o">-</span> <span class="nb">min</span><span class="p">(</span><span class="n">curve</span><span class="p">))</span> <span class="o">/</span> <span class="p">(</span><span class="nb">max</span><span class="p">(</span><span class="n">curve</span><span class="p">)</span> <span class="o">-</span> <span class="nb">min</span><span class="p">(</span><span class="n">curve</span><span class="p">))</span>
        <span class="c1"># Build the regressor model</span>
        <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">size</span><span class="o">-</span><span class="n">nx</span><span class="p">):</span>
            <span class="n">phi</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">serie</span><span class="p">[</span><span class="n">k</span><span class="p">:</span><span class="n">k</span><span class="o">+</span><span class="n">nx</span><span class="p">])</span>
            <span class="n">y</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">serie</span><span class="p">[</span><span class="n">k</span><span class="o">+</span><span class="n">nx</span><span class="p">])</span>
        <span class="c1"># Save the build regressors</span>
        <span class="n">regressors</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">phi</span><span class="p">)</span>
        <span class="n">outputs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">y</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">regressors</span><span class="p">,</span> <span class="n">outputs</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="Next-step-parameters">
<h2>Next step parameters<a class="headerlink" href="#Next-step-parameters" title="Permalink to this headline">¶</a></h2>
<p>Here we will create the regression problem for each light curve, and estimate the respective rigde bayes parameters. For that the <code class="docutils literal notranslate"><span class="pre">linear_model</span></code> library from <code class="docutils literal notranslate"><span class="pre">sklearn</span></code> will be used, specific the <code class="docutils literal notranslate"><span class="pre">BayesianRidge</span></code> object. To both create the regressor, for each light curve and then train the model, one must do the following</p>
<blockquote>
<div><p><em>Usually it is interesting to normalize the data before fitting a regression model.</em></p>
</div></blockquote>
<div class="nbinput nblast docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[14]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre>
<span></span><span class="kn">from</span> <span class="nn">sklearn</span> <span class="kn">import</span> <span class="n">linear_model</span>

<span class="n">bayes_data</span> <span class="o">=</span> <span class="p">{</span>
    <span class="s1">&#39;features&#39;</span><span class="p">:</span> <span class="p">{</span>
        <span class="s1">&#39;params&#39;</span><span class="p">:</span> <span class="p">[]</span>
    <span class="p">},</span>
    <span class="s1">&#39;labels&#39;</span><span class="p">:</span> <span class="n">curves</span><span class="p">[</span><span class="s1">&#39;lab&#39;</span><span class="p">]</span>
<span class="p">}</span>

<span class="c1"># Build the regression model</span>
<span class="n">regr</span><span class="p">,</span> <span class="n">out</span> <span class="o">=</span> <span class="n">build_regressor</span><span class="p">(</span><span class="n">curves</span><span class="p">[</span><span class="s1">&#39;y&#39;</span><span class="p">],</span> <span class="n">order</span><span class="o">=</span><span class="mi">20</span><span class="p">,</span> <span class="n">norm</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

<span class="c1"># Estimate the bayes regression model</span>
<span class="c1"># for each set of regressor and outputs</span>
<span class="k">for</span> <span class="n">phi</span><span class="p">,</span> <span class="n">y</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">regr</span><span class="p">,</span> <span class="n">out</span><span class="p">):</span>
    <span class="c1"># Create the model</span>
    <span class="n">clf</span> <span class="o">=</span> <span class="n">linear_model</span><span class="o">.</span><span class="n">BayesianRidge</span><span class="p">()</span>
    <span class="c1"># Estimate the model</span>
    <span class="n">clf</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span> <span class="n">phi</span><span class="p">,</span> <span class="n">y</span> <span class="p">)</span>
    <span class="c1"># Save the parameters</span>
    <span class="n">bayes_data</span><span class="p">[</span><span class="s1">&#39;features&#39;</span><span class="p">][</span><span class="s1">&#39;params&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span> <span class="n">clf</span><span class="o">.</span><span class="n">coef_</span> <span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="id1">
<h2>Save feature<a class="headerlink" href="#id1" title="Permalink to this headline">¶</a></h2>
<p>Here we just save the feature variable in a particular pickle file</p>
<div class="nbinput nblast docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[ ]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre>
<span></span><span class="n">file_name</span> <span class="o">=</span> <span class="s1">&#39;./features/bayes_data/nx_6/bayes_data.pkl&#39;</span>

<span class="n">output</span> <span class="o">=</span> <span class="nb">open</span><span class="p">(</span><span class="n">file_name</span><span class="p">,</span> <span class="s1">&#39;wb&#39;</span><span class="p">)</span>
<span class="n">pickle</span><span class="o">.</span><span class="n">dump</span><span class="p">(</span><span class="n">bayes_data</span><span class="p">,</span> <span class="n">output</span><span class="p">)</span>
<span class="n">output</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
</pre></div>
</div>
</div>
</div>
</div>
<div class="section" id="Feature:-Markov-Hidden-Models">
<h1>Feature: Markov Hidden Models<a class="headerlink" href="#Feature:-Markov-Hidden-Models" title="Permalink to this headline">¶</a></h1>
<hr class="docutils" />
<p>Here we will develop a time series prediction algorithm using the so called Hidden Markov Models. They are not much more than a state space model without the input signal… a model that freely vary provided an initial condition. The model can be simply mapped as</p>
<div class="math notranslate nohighlight">
\[x(k+1) = A x(k)\]</div>
<p>where our job is to determine the parameter matrix <span class="math notranslate nohighlight">\(A\)</span>. Note that <span class="math notranslate nohighlight">\(x(k)\)</span> has dimension <span class="math notranslate nohighlight">\(n_x\)</span> wich is the model complexity, and user provided.</p>
<blockquote>
<div><p><em>Here we actully will use a the library called</em> <code class="docutils literal notranslate"><span class="pre">`hmmlearn</span></code> &lt;<a class="reference external" href="https://hmmlearn.readthedocs.io/en/latest/tutorial.html">https://hmmlearn.readthedocs.io/en/latest/tutorial.html</a>&gt;`__ <em>to estimate the model.</em></p>
</div></blockquote>
<p>One might wonder the reason to estimate this prediction model. The idea is simple, the matrix <span class="math notranslate nohighlight">\(A\)</span> will caracterize the main behavior of the dynamic system, and then it is possible this summarized information of the time series (the <span class="math notranslate nohighlight">\(A\)</span> matrix) as feature for the classification machine learning algorithm further used.</p>
<div class="section" id="Preprocessing-data">
<h2>Preprocessing data<a class="headerlink" href="#Preprocessing-data" title="Permalink to this headline">¶</a></h2>
<p>But for that to work, we need to maintain the parameters of each estimated <span class="math notranslate nohighlight">\(A\)</span> matrix as close as possible to each other. This means that we first need to preprocess the data in a manner to maintain the same signal power within each curve. This can be done by detrending the time series, and then normalizing their values.</p>
<p>To detrend the data we will use the same library previouly used above from <code class="docutils literal notranslate"><span class="pre">scipy.signal</span></code>.</p>
<div class="nbinput nblast docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[15]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre>
<span></span><span class="kn">import</span> <span class="nn">scipy.signal</span> <span class="k">as</span> <span class="nn">ssg</span>

<span class="c1"># Create the feature data to be</span>
<span class="c1"># further saved for machine learning</span>
<span class="n">hmm_data</span> <span class="o">=</span> <span class="p">{</span>
    <span class="s1">&#39;y&#39;</span><span class="p">:</span> <span class="p">[],</span>
    <span class="s1">&#39;t&#39;</span><span class="p">:</span> <span class="n">curves</span><span class="p">[</span><span class="s1">&#39;t&#39;</span><span class="p">],</span>
    <span class="s1">&#39;labels&#39;</span><span class="p">:</span> <span class="n">curves</span><span class="p">[</span><span class="s1">&#39;lab&#39;</span><span class="p">],</span>
    <span class="s1">&#39;features&#39;</span><span class="p">:</span> <span class="p">{</span>
        <span class="s1">&#39;prob_matrix&#39;</span><span class="p">:</span> <span class="p">[]</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="c1"># Flags for the pipeline</span>
<span class="n">norm</span> <span class="o">=</span> <span class="kc">False</span>

<span class="c1"># Pre processing pipe line</span>
<span class="k">for</span> <span class="n">curve</span> <span class="ow">in</span> <span class="n">curves</span><span class="p">[</span><span class="s1">&#39;y&#39;</span><span class="p">]:</span>
    <span class="c1"># Detrend time series</span>
    <span class="n">series</span> <span class="o">=</span> <span class="n">ssg</span><span class="o">.</span><span class="n">detrend</span><span class="p">(</span><span class="n">curve</span><span class="p">,</span> <span class="nb">type</span><span class="o">=</span><span class="s1">&#39;linear&#39;</span><span class="p">)</span>
    <span class="c1"># Normalize (0, 1) time series</span>
    <span class="k">if</span> <span class="n">norm</span><span class="p">:</span>
        <span class="n">mins</span><span class="p">,</span> <span class="n">maxs</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">series</span><span class="p">),</span> <span class="nb">max</span><span class="p">(</span><span class="n">series</span><span class="p">)</span>
        <span class="n">series</span> <span class="o">=</span> <span class="p">(</span><span class="n">series</span> <span class="o">-</span> <span class="n">mins</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">maxs</span> <span class="o">-</span> <span class="n">mins</span><span class="p">)</span>
    <span class="c1"># Add time series to processing data</span>
    <span class="n">hmm_data</span><span class="p">[</span><span class="s1">&#39;y&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span> <span class="n">series</span> <span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="Estimate-HMM">
<h2>Estimate HMM<a class="headerlink" href="#Estimate-HMM" title="Permalink to this headline">¶</a></h2>
<p>Now we can just use the algorithm created to determine the Hidden Markov Model for each curve time series. For each curve, we can fetch the parameter called <code class="docutils literal notranslate"><span class="pre">transmat_</span></code> which is actually the transition probability matrix of the state space model, here known as <span class="math notranslate nohighlight">\(A\)</span>. From that we will have a <span class="math notranslate nohighlight">\(A\)</span> matrix for each curve… with model complexity equal to <span class="math notranslate nohighlight">\(n_x=\)</span> <code class="docutils literal notranslate"><span class="pre">n_components</span></code>, therefore making <span class="math notranslate nohighlight">\(A \in \Re_{(n_x, n_x)}\)</span>.</p>
<div class="nbinput nblast docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[16]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre>
<span></span><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">from</span> <span class="nn">hmmlearn</span> <span class="kn">import</span> <span class="n">hmm</span>

<span class="c1"># Model parameters</span>
<span class="n">cfgs</span> <span class="o">=</span> <span class="p">{</span>
    <span class="s1">&#39;n_components&#39;</span><span class="p">:</span> <span class="mi">8</span><span class="p">,</span>
    <span class="s1">&#39;covariance_type&#39;</span><span class="p">:</span> <span class="s1">&#39;full&#39;</span><span class="p">,</span>
    <span class="s1">&#39;n_iter&#39;</span><span class="p">:</span> <span class="mi">100</span>
<span class="p">}</span>

<span class="c1"># Compute each probability matrix</span>
<span class="k">for</span> <span class="n">curve_data</span> <span class="ow">in</span> <span class="n">hmm_data</span><span class="p">[</span><span class="s1">&#39;y&#39;</span><span class="p">]:</span>
    <span class="c1"># Create the hmm model</span>
    <span class="n">remodel</span> <span class="o">=</span> <span class="n">hmm</span><span class="o">.</span><span class="n">GaussianHMM</span><span class="p">(</span><span class="o">**</span><span class="n">cfgs</span><span class="p">)</span>
    <span class="c1"># Fit the hmm model to data</span>
    <span class="n">remodel</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span>
        <span class="n">curve_data</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">curve_data</span><span class="p">),</span><span class="mi">1</span><span class="p">))</span>
    <span class="c1"># Recover the probability matrix</span>
    <span class="n">hmm_data</span><span class="p">[</span><span class="s1">&#39;features&#39;</span><span class="p">][</span><span class="s1">&#39;prob_matrix&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span> <span class="n">remodel</span><span class="o">.</span><span class="n">transmat_</span> <span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="id2">
<h2>Save feature<a class="headerlink" href="#id2" title="Permalink to this headline">¶</a></h2>
<p>Here we just save the feature variable in a particular pickle file</p>
<div class="nbinput nblast docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[ ]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre>
<span></span><span class="n">file_name</span> <span class="o">=</span> <span class="s1">&#39;./features/hmm_data/nx_8/hmm_data.pkl&#39;</span>

<span class="n">output</span> <span class="o">=</span> <span class="nb">open</span><span class="p">(</span><span class="n">file_name</span><span class="p">,</span> <span class="s1">&#39;wb&#39;</span><span class="p">)</span>
<span class="n">pickle</span><span class="o">.</span><span class="n">dump</span><span class="p">(</span><span class="n">hmm_data</span><span class="p">,</span> <span class="n">output</span><span class="p">)</span>
<span class="n">output</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="Download-features">
<h2>Download features<a class="headerlink" href="#Download-features" title="Permalink to this headline">¶</a></h2>
<p>If the user does not want to run this pipeline step algorithm (since it takes time) one can just try to download the features, in several different setups from the Google Drive:</p>
<ul class="simple">
<li><p><a class="reference external" href="https://drive.google.com/drive/folders/19kALbQ5m1ppXxGTVMBaWA4KdIE9pmWfM?usp=sharing">Google drive access</a></p></li>
</ul>
<p>In this drive the user will find a repository called <code class="docutils literal notranslate"><span class="pre">features</span></code>, that will have this structure:</p>
<div class="highlight-json notranslate"><div class="highlight"><pre><span></span>./features
   │
   ├── bayes_data
   │     ├── nx_4
   │     │    ├── bayes_data.pkl
   │     │    └── norm_bayes_data.pkl
   │     ├── nx_6
   │     │    ├── bayes_data.pkl
   │     │    └── norm_bayes_data.pkl
   │     ⋮     ⋮
   │     └── nx_20
   │          ├── bayes_data.pkl
   │          └── norm_bayes_data.pkl
   │
   ├── freq_data
   │     │
   │     └── freq_data.pkl
   │
   └── hmm_data
         ├── nx_4
         │    ├── hmm_data.pkl
         │    └── norm_hmm_data.pkl
         ├── nx_6
         │    ├── hmm_data.pkl
         │    └── norm_hmm_data.pkl
         ⋮     ⋮
         └── nx_20
              ├── hmm_data.pkl
              └── norm_hmm_data.pkl
</pre></div>
</div>
<p>Here the frequency spectrum approach only has one feature type to be used. But the Hidden Markov Model and the Naive Bayes likelihood has several one, provided the combination of the parameters <span class="math notranslate nohighlight">\(n_x\)</span> and the possibility to normalize or not the light curve time series. Thence, if the user want the parameters for the model with <span class="math notranslate nohighlight">\(n_x=8\)</span>, for the case considering the normalized data, it will be found at <code class="docutils literal notranslate"><span class="pre">/features/hmm_data/nx_8/norm_hmm_data.pkl</span></code> for the hidden markov model approach,
and <code class="docutils literal notranslate"><span class="pre">/features/bayes_data/nx_8/norm_bayes_data.pkl</span></code> for the naive bayes.</p>
</div>
</div>


           </div>
           
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="03 - Machine Learning - XGBoost Classifier.html" class="btn btn-neutral float-right" title="XGBoost Classifier" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="01 - Reading and Plotting.html" class="btn btn-neutral float-left" title="Read .fits raw data" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2020, Marcelo Mendes Lafetá Lima

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>